<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine Hóa học AI v3.0 - Nhà Hóa học AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Variables CSS cho màu sắc dễ quản lý */
        :root {
            --dark-bg: #111827;
            --light-bg: #1f2937;
            --panel-bg: #374151;
            --accent-color: #8b5cf6; /* Màu tím làm điểm nhấn */
            --danger-color: #ef4444; /* Màu đỏ cho lỗi */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e5e7eb; /* Màu chữ sáng */
            padding: 1rem; /* Padding tổng thể */
        }
        .simulation-container {
            width: 95vw;
            max-width: 1000px;
            background: var(--light-bg);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column; /* Sắp xếp các phần tử theo chiều dọc */
            gap: 1rem; /* Khoảng cách giữa các phần tử */
        }
        /* THAY ĐỔI: Thêm hiệu ứng bóng đổ cho tiêu đề */
        h1 {
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
            transition: text-shadow 0.3s ease-in-out;
        }
        h1:hover {
            text-shadow: 0 0 25px rgba(139, 92, 246, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #reaction-chamber {
            position: relative;
            width: 100%;
            height: 500px; /* Chiều cao cố định cho buồng phản ứng */
            background: var(--dark-bg);
            border-radius: 1rem;
            overflow: hidden; /* Đảm bảo nội dung không tràn ra ngoài */
            cursor: grab; /* Con trỏ kéo */
            display: flex; /* Dùng flexbox để căn giữa nội dung lỗi WebGL */
            justify-content: center;
            align-items: center;
        }
        #reaction-chamber canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-panel {
            background: var(--panel-bg);
            border-radius: 1rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        /* Cập nhật style cho textarea */
        #equation-input {
            flex-grow: 1; /* Cho phép textarea mở rộng */
            background: var(--light-bg);
            border: 1px solid var(--accent-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #fff;
            outline: none; /* Bỏ viền outline mặc định */
            transition: border-color 0.3s; /* Hiệu ứng chuyển màu viền */
            resize: vertical; /* Cho phép thay đổi kích thước theo chiều dọc */
            min-height: 80px; /* Chiều cao tối thiểu */
        }
        #equation-input:focus {
            border-color: #a78bfa; /* Màu viền khi focus */
        }
        /* Class mới cho trạng thái lỗi */
        #equation-input.input-error {
            border-color: var(--danger-color);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.5); /* Shadow đỏ cho lỗi */
        }

        .main-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease; /* Hiệu ứng chuyển động mượt mà */
            font-weight: 600;
            display: flex; /* Dùng flexbox để căn giữa spinner và text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .main-btn:hover {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            transform: translateY(-2px); /* Hiệu ứng nhấc nhẹ */
        }
        .main-btn:disabled {
            background-image: none;
            background-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #controls-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap; /* Cho phép các nút xuống dòng trên màn hình nhỏ */
            justify-content: center; /* Căn giữa các nút */
        }
        .icon-btn {
            background: transparent;
            border: 1px solid #6b7280;
            color: #d1d5db;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2rem;
        }
        .icon-btn:hover {
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }
        .icon-btn:disabled {
            color: #6b7280;
            border-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Thêm style cho thanh trượt tốc độ và thời gian */
        .speed-control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem; /* Khoảng cách với thanh progress bar */
        }
        .speed-btn {
            background-color: var(--panel-bg);
            color: #e5e7eb;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            border: 1px solid #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        .speed-btn:hover:not(.active) {
            border-color: var(--accent-color);
            color: white;
        }
        .speed-btn.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }
        .speed-btn:disabled {
            background-color: #4b5563;
            border-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }

        #timeline-slider {
            width: 100%;
            -webkit-appearance: none; /* Ẩn giao diện mặc định */
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            margin-top: 1rem; /* Khoảng cách với các nút điều khiển */
        }
        #timeline-slider:hover {
            opacity: 1;
        }
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }


        #progress-container {
            flex-grow: 1;
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            overflow: hidden;
            display: none; /* Ẩn thanh progress bar cũ, thay bằng slider mới */
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 99px;
            transition: width 0.3s ease; /* Hiệu ứng chuyển động cho thanh tiến trình */
        }
        /* Cập nhật style cho info-text để nó hoạt động như toast */
        #info-text {
            text-align: center;
            min-height: 24px; /* Giữ chỗ để tránh nhảy layout */
            color: #e5e7eb;
            opacity: 0; /* Mặc định ẩn */
            transition: opacity 0.3s ease-in-out, color 0.3s ease-in-out; /* Hiệu ứng chuyển đổi */
            font-size: 1rem; /* THAY ĐỔI: Tăng kích thước chữ */
            font-weight: 600; /* THAY ĐỔI: Tăng độ đậm chữ */
        }
        #info-text.error-message {
            color: var(--danger-color); /* Màu đỏ cho lỗi */
        }

        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Thông báo lỗi WebGL */
        .webgl-error-message {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--danger-color); /* Nền đỏ cho lỗi */
            color: white;
            border-radius: 0.75rem;
            font-size: 1rem;
            max-width: 80%;
        }
        .webgl-error-message h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .webgl-error-message p {
            margin-bottom: 0.5rem;
        }
        .webgl-error-message a {
            color: #fee2e2;
            text-decoration: underline;
        }
        .webgl-error-message a:hover {
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <h1 class="text-2xl font-bold text-center mb-4">Nhà Hóa học AI v3.0</h1>
        <div id="reaction-chamber">
            <!-- Thông báo lỗi WebGL sẽ được chèn vào đây nếu cần -->
        </div>
        <div class="ui-panel">
            <div class="input-group">
                <textarea id="equation-input" rows="3" placeholder="Nhập các chất tham gia (vd: H2 + O2), hoặc phương trình (vd: 2H2 + O2 -> 2H2O), hoặc mô tả (vd: Phản ứng đốt cháy Metan)..."></textarea>
                <button id="generate-btn" class="main-btn">
                    Tạo Phản ứng
                    <div id="loading-spinner" class="spinner hidden"></div>
                </button>
            </div>
             <div id="controls-bar">
                <button id="play-pause-btn" class="icon-btn" disabled>▶️</button>
                <button id="restart-btn" class="icon-btn" disabled>🔄</button>
                
                <!-- THAY ĐỔI: Thêm nhóm điều khiển tốc độ -->
                <div class="speed-control-group">
                    <button class="speed-btn" data-speed="0.5" disabled>0.5x</button>
                    <button class="speed-btn active" data-speed="1" disabled>1x</button>
                    <button class="speed-btn" data-speed="2" disabled>2x</button>
                </div>

                <!-- Thanh progress bar cũ (giờ ẩn đi) -->
                <div id="progress-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <!-- THAY ĐỔI: Thêm thanh trượt thời gian -->
            <input type="range" id="timeline-slider" min="0" max="100" value="0" disabled>

            <p id="info-text">Hãy xem AI dự đoán và diễn họa phản ứng hóa học!</p>
        </div>
    </div>

    <!-- Imports -->
    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/" } }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Firebase, AI, 3D Engine Setup ---
        const firebaseConfig = { apiKey: "AIzaSyBVpguEIjTnIVOk1Ld0u-BGC7nM-pSww_o", authDomain: "aihoa-ac63b.firebaseapp.com", projectId: "aihoa-ac63b", storageBucket: "aihoa-ac63b.firebasestorage.app", messagingSenderId: "241068548961", appId: "1:241068548961:web:33d4126d020e9372d15b20"};
        let model;
        try {
            const app = initializeApp(firebaseConfig);
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            // Sử dụng gemini-2.5-flash để tạo nội dung
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        } catch (e) {
            console.error("Lỗi khởi tạo Firebase/AI:", e);
            // Hiển thị lỗi nếu không thể khởi tạo AI
            displayMessage("Lỗi: Không thể kết nối với AI Engine. Vui lòng kiểm tra console để biết chi tiết.", true);
            document.getElementById('generate-btn').disabled = true;
        }

        const chamber = document.getElementById('reaction-chamber');
        let renderer, scene, camera, controls, composer, mainTimeline;
        let molecules = [];
        let particles; // Khai báo biến cho hệ thống hạt

        function init3D() {
            // Xóa nội dung lỗi WebGL cũ nếu có
            chamber.innerHTML = '';
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, chamber.clientWidth / chamber.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                chamber.appendChild(renderer.domElement);

                // Cài đặt Post-processing (Bloom effect)
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                const outputPass = new OutputPass();

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
                composer.addPass(outputPass);

                // Thêm đèn
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                camera.position.z = 15;

                // Điều khiển OrbitControls cho phép xoay, phóng to/thu nhỏ khung cảnh
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Thêm hệ thống hạt (particles)
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const particleColor = new THREE.Color(0xffffff); // Màu trắng
                const sphereRadius = 20; // Bán kính khu vực hạt xuất hiện

                for (let i = 0; i < particleCount; i++) {
                    // Tạo vị trí ngẫu nhiên trong một hình cầu
                    const x = (Math.random() - 0.5) * 2 * sphereRadius;
                    const y = (Math.random() - 0.5) * 2 * sphereRadius;
                    const z = (Math.random() - 0.5) * 2 * sphereRadius;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // Gán màu trắng với độ mờ nhẹ
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                }

                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1, // Kích thước hạt
                    vertexColors: true, // Sử dụng màu từ attribute
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending // Hiệu ứng cộng màu, làm hạt sáng hơn
                });

                particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                particles.visible = true; // Mặc định hiển thị hạt

                // Vòng lặp hoạt ảnh chính
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    // Quay các hạt nhẹ nhàng
                    if (particles && particles.visible) {
                        particles.rotation.y += 0.0005;
                        particles.rotation.x += 0.0002;
                    }
                    composer.render();
                }
                animate();

                // Lắng nghe sự kiện thay đổi kích thước cửa sổ
                window.addEventListener('resize', () => {
                    camera.aspect = chamber.clientWidth / chamber.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                    composer.setSize(chamber.clientWidth, chamber.clientHeight);
                });

            } catch (error) {
                console.error("Lỗi khởi tạo WebGL:", error);
                // Hiển thị thông báo lỗi thân thiện hơn
                chamber.innerHTML = `
                    <div class="webgl-error-message">
                        <h2>Lỗi WebGL</h2>
                        <p>Trình duyệt của bạn có thể không hỗ trợ hoặc WebGL đang bị tắt.</p>
                        <p>Để trải nghiệm hoạt ảnh 3D, vui lòng đảm bảo trình duyệt của bạn được cập nhật và WebGL được bật.</p>
                        <p><a href="https://get.webgl.org/" target="_blank">Kiểm tra trạng thái WebGL của bạn tại đây</a></p>
                    </div>
                `;
                generateBtn.disabled = true;
                throw new Error("WebGL init failed");
            }
        }

        // --- Core Application Logic ---
        const generateBtn = document.getElementById('generate-btn');
        const input = document.getElementById('equation-input');
        const infoText = document.getElementById('info-text');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const speedButtons = document.querySelectorAll('.speed-btn');
        const timelineSlider = document.getElementById('timeline-slider');

        let currentMessageTimeout;
        function displayMessage(message, isError = false) {
            if (currentMessageTimeout) {
                clearTimeout(currentMessageTimeout);
                currentMessageTimeout = null;
            }

            infoText.textContent = message;
            if (isError) {
                infoText.classList.add('error-message');
            } else {
                infoText.classList.remove('error-message');
            }
            gsap.to(infoText, { opacity: 1, duration: 0.3, ease: "power2.out" });

            if (!isError) {
                currentMessageTimeout = setTimeout(() => {
                    gsap.to(infoText, { opacity: 0, duration: 0.5, ease: "power2.in" });
                }, 5000);
            }
        }

        function clearScene() {
            molecules.forEach(m => {
                m.children.forEach(c => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                });
                scene.remove(m);
            });
            molecules = [];
        }

        function drawMolecule3D(moleculeDef, x, y, z) {
            const group = new THREE.Group();
            const atomRadius = 0.5;

            moleculeDef.atoms.forEach((atomDef, i) => {
                const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: atomDef.color,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: '#000000'
                });
                const atomMesh = new THREE.Mesh(geometry, material);

                if (moleculeDef.atoms.length > 1) {
                    const angle = (i / moleculeDef.atoms.length) * 2 * Math.PI;
                    atomMesh.position.x = Math.cos(angle) * atomRadius * 1.5;
                    atomMesh.position.y = Math.sin(angle) * atomRadius * 1.5;
                }
                group.add(atomMesh);
            });

            group.position.set(x, y, z);
            scene.add(group);
            molecules.push(group);
            return group;
        }

        // --- Animation Engine ---
        function runAnimation(plan) {
            if (mainTimeline) mainTimeline.kill();
            clearScene();
            
            // Ẩn các hạt khi hoạt ảnh bắt đầu
            if (particles) {
                particles.visible = false;
            }

            displayMessage(`Đang chuẩn bị hoạt ảnh cho: ${plan.title}`);

            mainTimeline = gsap.timeline({
                onUpdate: () => {
                    timelineSlider.value = mainTimeline.progress() * 100;
                    playPauseBtn.textContent = mainTimeline.paused() ? "▶️" : "⏸️";
                },
                onComplete: () => {
                    displayMessage("Hoạt ảnh hoàn tất!");
                    playPauseBtn.textContent = "▶️";
                    playPauseBtn.disabled = true;
                    timelineSlider.disabled = true;
                    speedButtons.forEach(btn => btn.disabled = true);
                    // Hiện các hạt khi hoạt ảnh kết thúc
                    if (particles) {
                        particles.visible = true;
                    }
                }
            });

            playPauseBtn.disabled = false;
            restartBtn.disabled = false;
            timelineSlider.disabled = false;
            speedButtons.forEach(btn => btn.disabled = false);

            playPauseBtn.textContent = "⏸️";

            const reactantObjects = [];
            let reactantX = -10;

            plan.reactants.forEach((r) => {
                for (let j = 0; j < r.count; j++) {
                    const moleculeObj = drawMolecule3D(r, reactantX, (j % 2 === 0 ? 1 : -1) * 4, 0);
                    reactantObjects.push({ obj: moleculeObj });
                    reactantX += 5;
                }
            });

            plan.animationSteps.forEach(step => {
                mainTimeline.add(() => { displayMessage(step.text || '...'); }, step.type);

                if (step.type === 'move_to_center') {
                    mainTimeline.to(camera.position, { z: 25, duration: 2.5, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach((m, i) => {
                        mainTimeline.to(m.obj.position, { x: (i % 3 - 1) * 3, y: Math.floor(i / 3) * 3 - 1, z: 0, duration: 2.5, ease: "power2.inOut" }, step.type);
                    });
                } else if (step.type === 'break_bonds') {
                    mainTimeline.to(camera.position, { z: 12, duration: 2, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach(m => {
                        m.obj.children.forEach((atomMesh, i) => {
                            mainTimeline.to(atomMesh.material.emissive, { r: 1, g: 1, b: 0.8, duration: 1, ease: "power2.in" }, step.type);
                            const angle = (i / m.obj.children.length) * 2 * Math.PI;
                            mainTimeline.to(atomMesh.position, { x: atomMesh.position.x + Math.cos(angle) * 0.8, y: atomMesh.position.y + Math.sin(angle) * 0.8, duration: 2, ease: "back.out(4)" }, step.type);
                        });
                    });
                } else if (step.type === 'rearrange') {
                    reactantObjects.forEach(m => {
                        mainTimeline.to(m.obj.children.map(c => c.material), { opacity: 0, duration: 1, onComplete: () => scene.remove(m.obj) }, step.type);
                    });

                    if (plan.isExothermic) {
                        mainTimeline.add(() => {
                            const shockwaveGeo = new THREE.TorusGeometry(1, 0.1, 16, 100);
                            const shockwaveMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 1 });
                            const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
                            shockwave.rotation.x = Math.PI / 2;
                            scene.add(shockwave);
                            gsap.to(shockwave.scale, { x: 20, y: 20, z: 20, duration: 2, ease: "power1.out" });
                            gsap.to(shockwave.material, { opacity: 0, duration: 2, ease: "power1.out", onComplete: () => scene.remove(shockwave) });
                        }, step.type + "+=0.5");

                    }

                    let productX = -5;
                    plan.products.forEach(p => {
                        for (let j = 0; j < p.count; j++) {
                            const productObj = drawMolecule3D(p, productX, (j % 2 === 0 ? 1 : -1) * 3, 0);
                            productObj.children.forEach(c => { c.material.transparent = true; c.material.opacity = 0; });
                            mainTimeline.to(productObj.children.map(c => c.material), { opacity: 1, duration: 2 }, step.type + "+=1");
                            mainTimeline.to(productObj.children.map(c => c.material.emissive), { r: 0, g: 0, b: 0, duration: 2 }, step.type + "+=1");
                            productX += 5;
                        }
                    });
                }
            });
        }

        async function generateReactionPlan() {
            if (!model || !renderer) {
                displayMessage("Lỗi: Engine AI hoặc môi trường 3D chưa sẵn sàng.", true);
                return;
            }
            const userInput = input.value.trim();
            if (!userInput) {
                displayMessage("Vui lòng nhập các chất tham gia để tạo phản ứng.", true);
                input.classList.add('input-error');
                return;
            } else {
                input.classList.remove('input-error');
            }

            displayMessage('AI đang tư duy... 🧠');
            generateBtn.disabled = true;
            loadingSpinner.classList.remove('hidden');
            playPauseBtn.disabled = true;
            restartBtn.disabled = true;
            timelineSlider.disabled = true;
            speedButtons.forEach(btn => btn.disabled = true);

            // Ẩn các hạt khi AI đang tạo phản ứng
            if (particles) {
                particles.visible = false;
            }

            const prompt = `
            Từ các chất tham gia do người dùng cung cấp là: "${userInput}".
            Hãy thực hiện các bước sau một cách tuần tự:
            1. Dự đoán sản phẩm hóa học có khả năng xảy ra nhất trong điều kiện tiêu chuẩn.
            2. Viết phương trình hóa học đầy đủ và đã được cân bằng cho phản ứng đó.
            3. Dựa trên phương trình bạn vừa tạo, hãy tạo một kịch bản hoạt ảnh chi tiết dưới dạng một đối tượng JSON.

            Đối tượng JSON phải có cấu trúc chính xác như sau:
            - "title": (string) Phương trình hóa học đầy đủ mà bạn đã tạo (ví dụ: "2H2 + O2 -> 2H2O").
            - "isExothermic": (boolean) Phản ứng có tỏa nhiệt hay không (true nếu tỏa nhiệt, false nếu thu nhiệt hoặc không xác định).
            - "reactants": (array) Một mảng các đối tượng chất phản ứng, mỗi đối tượng có dạng {molecule: string, count: number, atoms: [{symbol: string, color: string}]}.
            - "products": (array) Một mảng các đối tượng sản phẩm, cấu trúc tương tự reactants.
            - "animationSteps": (array) Một mảng các bước hoạt ảnh, mỗi bước có dạng {type: 'move_to_center' | 'break_bonds' | 'rearrange', text: string}.
                - 'move_to_center': Các phân tử di chuyển vào trung tâm buồng phản ứng.
                - 'break_bonds': Liên kết giữa các nguyên tử bị phá vỡ, các nguyên tử tách rời.
                - 'rearrange': Các nguyên tử tự sắp xếp lại để tạo thành sản phẩm mới.

            Sử dụng các màu sau cho nguyên tử (hãy tự suy ra các màu khác nếu cần):
            - H: #FFFFFF (Trắng)
            - O: #FF6B6B (Đỏ)
            - C: #333333 (Xám đen)
            - N: #6B9AFF (Xanh dương)
            - Fe: #A19D94 (Xám kim loại)
            - S: #FFF36B (Vàng)
            - Cl: #6BFF8B (Xanh lá)
            - Na: #B06BFF (Tím)
            - K: #8A2BE2 (Tím nhạt)
            - Mg: #BDB76B (Vàng xanh)
            - Ca: #DDA0DD (Tím hoa cà)
            - Al: #C0C0C0 (Bạc)
            - P: #FFA500 (Cam)
            - Br: #A52A2A (Nâu)
            - I: #4B0082 (Chàm)

            Quan trọng: Chỉ trả lời bằng một khối mã JSON hợp lệ duy nhất, không chứa "'''json" hay bất kỳ văn bản giải thích nào khác.
            `;

            try {
                const result = await model.generateContent(prompt);
                const textResponse = result.response.text();
                const cleanedText = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
                const plan = JSON.parse(cleanedText);

                runAnimation(plan);
            } catch (error) {
                console.error("Lỗi phân tích hoặc tạo hoạt ảnh:", error);
                displayMessage("Đã có lỗi xảy ra. AI có thể đã trả về định dạng không đúng hoặc gặp lỗi. Vui lòng thử lại.", true);
                // Hiện các hạt trở lại nếu có lỗi
                if (particles) {
                    particles.visible = true;
                }
            } finally {
                generateBtn.disabled = false;
                loadingSpinner.classList.add('hidden');
            }
        }

        playPauseBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.paused(!mainTimeline.paused());
            }
        });

        restartBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.restart();
            }
        });

        speedButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const speed = parseFloat(event.target.dataset.speed);
                if (mainTimeline) {
                    mainTimeline.timeScale(speed);
                }
                speedButtons.forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            });
        });

        timelineSlider.addEventListener('input', () => {
            if (mainTimeline) {
                mainTimeline.progress(timelineSlider.value / 100);
            }
        });

        init3D();
        generateBtn.addEventListener('click', generateReactionPlan);
        displayMessage("Hãy xem AI dự đoán và diễn họa phản ứng hóa học!");
    </script>
</body>
</html>

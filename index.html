<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bảng Tuần Hoàn Tương Tác - Xu hướng Tuần hoàn</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles already present */
        :root {
            font-size: 10px;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            padding: 1.5rem;
        }
        .controls-wrapper {
            max-width: 1200px;
            margin: 0 auto 1rem auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .top-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
        }
        .search-container {
            display: flex;
            align-items: center;
            background-color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .search-container input {
            border: none;
            outline: none;
            padding: 0.5rem;
            font-size: 1.4rem;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group label {
            font-weight: 700;
            font-size: 1.6rem;
            color: #0056b3;
        }
        .control-group button, .control-group .trend-button {
            background-color: #e0f2fe;
            border: 1px solid #007bff;
            color: #007bff;
            font-weight: bold;
            border-radius: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.4rem;
            padding: 0.5rem 1.2rem;
        }
        .control-group button:hover, .control-group .trend-button:hover {
            background-color: #cce9ff;
        }
        .control-group .trend-button.selected {
             background-color: #007bff;
             color: white;
        }
        .control-group input {
            width: 7rem;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 0.5rem;
            font-size: 1.5rem;
            font-weight: 500;
        }
        .container {
            max-width: 1400px;
            width: 100%;
            margin: auto;
        }
        .status-message { text-align: center; margin-bottom: 1rem; font-size: 1.4rem; font-weight: 500; color: #555; height: 2rem; transition: color 0.3s ease; }
        .status-message.error-text { color: #dc3545; }
        .status-message.success-text { color: #28a745; }
        .status-message.info-text { color: #0056b3; }
        .legend-container { display: flex; justify-content: center; flex-wrap: wrap; gap: 0.8rem; max-width: 1200px; margin: 0 auto 2rem auto; }
        .legend-item { padding: 0.6rem 1.2rem; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 1.2rem; font-weight: 500; border: 1px solid transparent; }
        .legend-item:hover { opacity: 0.8; }
        .legend-item.selected { border: 1px solid #007bff; box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); transform: translateY(-2px); }
        .trend-legend-container { display: flex; justify-content: center; align-items: center; gap: 1rem; margin: 0 auto 2rem auto; font-size: 1.4rem; font-weight: 500; }
        .trend-legend-gradient { width: 200px; height: 20px; border-radius: 5px; border: 1px solid #ccc; }
        
        .periodic-table-wrapper { display: grid; grid-template-columns: 2.5rem repeat(18, 1fr); gap: 4px; }
        .period-number { display: flex; align-items: center; justify-content: center; font-size: 1.4rem; font-weight: 700; color: #555; }
        .periodic-table-grid { grid-column: 2 / span 18; display: grid; grid-template-columns: repeat(18, minmax(0, 1fr)); gap: 4px; }
        .element-cell { border-radius: 4px; padding: 0.5rem 0.2rem; display: flex; flex-direction: column; cursor: pointer; transition: all 0.2s ease-in-out, opacity 0.3s ease, filter 0.3s ease; font-size: 1rem; line-height: 1.1; min-height: 60px; position: relative; text-align: center; color: #333; }
        .element-cell:hover { transform: scale(1.1); z-index: 10; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .element-cell.dimmed { opacity: 0.2; filter: grayscale(80%); pointer-events: none; }
        .element-number { font-size: 1.1rem; font-weight: 500; position: absolute; top: 4px; left: 4px; }
        .element-symbol { font-size: 1.8rem; font-weight: 700; margin-top: 0.2rem; flex-grow: 1; display: flex; align-items: center; justify-content: center; }
        .element-name, .element-mass { font-size: 1rem; margin-top: 0.1rem; }
        
        .state-solid { color: #000000; } .state-liquid { color: #008000; } .state-gas { color: #ff0000; } .state-unknown { color: #888888; }
        .alkali-metal { background-color: #ffcdd2; border: 1px solid #e57373; } .alkaline-earth-metal { background-color: #ffe0b2; border: 1px solid #ffb74d; }
        .transition-metal { background-color: #e1f5fe; border: 1px solid #4fc3f7; } .post-transition-metal { background-color: #b2dfdb; border: 1px solid #4db6ac; }
        .metalloid { background-color: #cfd8dc; border: 1px solid #90a4ae; } .other-nonmetal { background-color: #f0f4c3; border: 1px solid #dce775; }
        .halogen { background-color: #d1c4e9; border: 1px solid #9575cd; } .noble-gas { background-color: #b3e5fc; border: 1px solid #4dd0e1; }
        .lanthanide { background-color: #fff9c4; border: 1px solid #fff176; } .actinide { background-color: #ffccbc; border: 1px solid #ff8a65; }
        .no-data { background-color: #f5f5f5; border: 1px solid #e0e0e0; color: #9e9e9e; }
        .empty-cell { visibility: hidden; pointer-events: none; }
        .lanthanide-ref, .actinide-ref { background-color: #d1eaff; border: 1px solid #a6d4fa; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
        
        .f-block-wrapper { margin: 2rem auto; max-width: 1060px; }
        .f-block-grid { display: grid; grid-template-columns: 2.5rem 2.7rem 1fr; gap: 4px; align-items: center; }
        .f-block-table { display: grid; grid-template-columns: repeat(15, 1fr); gap: 4px; }
    
        #bottomSheetOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; display: none; }
        #bottomSheet { position: fixed; bottom: 0; left: 0; width: 100%; max-height: 80vh; background-color: #ffffff; border-top-left-radius: 20px; border-top-right-radius: 20px; box-shadow: 0 -8px 20px rgba(0,0,0,0.2); z-index: 1001; transform: translateY(100%); transition: transform 0.3s ease-out; display: flex; flex-direction: column; }
        #bottomSheet.active { transform: translateY(0); }
        /* Adjusted bottomSheetContent padding, font-size, line-height */
        #bottomSheetContent {
            padding: 30px;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 1.6rem; /* Tăng kích thước font cơ bản để dễ đọc */
            line-height: 1.8; /* Tăng chiều cao dòng để dễ đọc */
            color: #333;
        }
        #bottomSheet .close-button { position: sticky; top: 0; align-self: flex-end; margin: 15px 15px 0 0; background: #e0e0e0; border: none; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; cursor: pointer; z-index: 1002; }
        #bottomSheetContent h3 { font-size: 2.2rem; font-weight: 700; color: #007bff; margin-bottom: 15px; }
        
        .loading-spinner { display: flex; justify-content: center; align-items: center; min-height: 100px; }
        .spinner { border: 4px solid rgba(0, 123, 255, 0.3); border-left-color: #007bff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        .spinner-small { width: 20px; height: 20px; border-width: 2px; } /* Smaller spinner for trend explanation */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Tooltip Styles */
        #elementTooltip {
            position: fixed;
            background-color: #2d3748; /* Default dark background, will be overridden by element color */
            color: #000000; /* Text color now black as requested */
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            font-size: 1.3rem;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 1000;
            max-width: 250px;
            text-align: left;
            border: 1px solid rgba(0, 123, 255, 0.3); /* Subtle border */
        }

        #elementTooltip.visible {
            opacity: 1;
        }

        #elementTooltip p {
            margin-bottom: 0.25rem;
        }
        #elementTooltip p:last-child {
            margin-bottom: 0;
        }
        #elementTooltip strong {
            font-weight: 600;
            color: #333; /* Darker color for labels in tooltip for better contrast on lighter backgrounds */
        }

        /* Bottom Sheet Content Styling Improvements */
        #bottomSheetContent {
            padding: 30px; /* Tăng padding để nội dung có không gian thở */
            overflow-y: auto;
            flex-grow: 1;
            font-size: 1.6rem; /* Kích thước font cơ bản dễ đọc hơn, tương tự các thông tin đầu */
            line-height: 1.7; /* Tăng chiều cao dòng để dễ đọc */
            color: #333; /* Màu chữ chính */
        }
        /* Adjusted the h3 specifically within #bottomSheet to differentiate from AI generated content */
        #bottomSheet .bottom-sheet-header h3 {
            font-size: 2.8rem; /* Tiêu đề lớn hơn, nổi bật hơn */
            font-weight: 700;
            color: #0056b3; /* Màu xanh đậm cho tiêu đề chính */
            margin-bottom: 0; /* Đặt lại margin để phù hợp với header flex */
            text-align: left; /* Căn trái tiêu đề trong header */
            flex-grow: 1; /* Cho phép tiêu đề chiếm không gian */
        }
        #bottomSheetContent hr {
            border: none;
            border-top: 1px solid #e0e0e0; /* Đường kẻ mảnh, tinh tế */
            margin: 20px 0; /* Khoảng cách trên dưới đường kẻ */
        }
        #geminiDetailContent strong {
            font-weight: 700;
            color: #007bff; /* Màu xanh nổi bật cho các nhãn quan trọng */
            margin-right: 5px; /* Khoảng cách giữa nhãn và nội dung */
        }
        #geminiDetailContent p {
            margin-bottom: 10px; /* Khoảng cách giữa các đoạn văn */
        }
        #geminiDetailContent ul,
        #geminiDetailContent ol {
            margin-top: 10px;
            margin-left: 20px; /* Thụt lề cho danh sách */
            list-style-type: disc; /* Kiểu dấu chấm cho danh sách không thứ tự */
        }
        #geminiDetailContent ol {
            list-style-type: decimal; /* Kiểu số cho danh sách có thứ tự */
        }
        #geminiDetailContent li {
            margin-bottom: 5px; /* Khoảng cách giữa các mục danh sách */
            padding-left: 5px;
        }
        /* Styling for headings possibly generated by Markdown within Gemini content */
        /* These headings will be within #geminiDetailContent, so target them specifically */
        #geminiDetailContent h1, #geminiDetailContent h2, #geminiDetailContent h3, #geminiDetailContent h4, #geminiDetailContent h5, #geminiDetailContent h6 {
            font-weight: 600;
            color: #444;
            margin-top: 25px;
            margin-bottom: 15px;
            border-bottom: 1px solid #f0f0f0; /* Đường kẻ dưới tiêu đề phụ */
            padding-bottom: 5px;
        }
        #geminiDetailContent h2 { font-size: 2.2rem; }
        #geminiDetailContent h3 { font-size: 1.8rem; }
        #geminiDetailContent h4 { font-size: 1.6rem; }
        
        .bottom-sheet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px 10px 30px;
            border-bottom: 1px solid #e0e0e0;
            background-color: #f8f8f8;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }
        #bottomSheet .close-button {
            position: relative;
            top: auto;
            align-self: center;
            margin: 0;
            background: #dcdcdc;
            color: #555;
            transition: background 0.2s ease;
        }
        #bottomSheet .close-button:hover {
            background: #c0c0c0;
        }

        /* Q&A Modal Styles */
        #qnaModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }

        #qnaModal {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 700px; /* Increased max-width for better Q&A content */
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: fadeInScale 0.3s ease-out forwards;
            display: flex;
            flex-direction: column;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        #qnaModal .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #e0e0e0;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            cursor: pointer;
            z-index: 10;
            transition: background 0.2s ease;
        }
        #qnaModal .close-button:hover {
            background: #c0c0c0;
        }

        #qnaModal h4 {
            font-size: 2.4rem; /* Larger heading for Q&A */
            font-weight: 700;
            color: #0056b3;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        #qnaModal textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 1rem;
            font-size: 1.6rem; /* Larger font for input */
            outline: none;
            resize: vertical;
            margin-bottom: 1rem;
        }

        #qnaModal button {
            background-color: #007bff;
            color: white;
            font-weight: bold;
            border-radius: 0.75rem;
            padding: 1rem 2rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-size: 1.6rem;
            align-self: flex-end; /* Align to the right */
        }
        #qnaModal button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        #qnaResponseContainer {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: #e8f5e9; /* Light green background for response */
            border: 1px solid #c8e6c9; /* Green border */
            border-radius: 8px;
            color: #1b5e20; /* Dark green text */
            font-size: 1.6rem; /* Consistent font size for response */
            line-height: 1.7;
            word-wrap: break-word;
            flex-grow: 1; /* Allow response area to grow */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically when loading */
        }
        #qnaResponseContainer p {
            margin-bottom: 0.5rem;
        }
        #qnaResponseContainer p:last-child {
            margin-bottom: 0;
        }
        #qnaResponseContainer strong {
            color: #2e7d32; /* Darker green for labels */
        }
        #qnaResponseContent h1, #qnaResponseContent h2, #qnaResponseContent h3, #qnaResponseContent h4, #qnaResponseContent h5, #qnaResponseContent h6 {
            font-weight: 600;
            color: #2e7d32; /* Consistent heading color */
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid #d0e0d0;
            padding-bottom: 5px;
        }
        #qnaResponseContent h2 { font-size: 2rem; }
        #qnaResponseContent h3 { font-size: 1.8rem; }
        #qnaResponseContent h4 { font-size: 1.6rem; }
        
    </style>
</head>
<body>
    <div class="controls-wrapper">
        <div class="top-controls">
            <div class="search-container">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-search text-gray-400" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                <input type="text" id="searchInput" placeholder="Tìm kiếm nguyên tố...">
            </div>
            <div class="control-group" id="trends-control">
                 <button class="trend-button" data-trend="electronegativity">Độ âm điện</button>
                 <button class="trend-button" data-trend="ionizationEnergy">NL ion hóa</button>
                 <button class="trend-button" data-trend="atomicRadius">Bán kính NT</button>
                 <button class="trend-button selected" data-trend="none">Tắt</button>
            </div>
            <div class="control-group">
                <label>Nhiệt độ:</label>
                <input type="number" id="kelvinInput" value="298">
                <label>K</label>
            </div>
        </div>

        <!-- Trend Explanation Container -->
        <div id="trendExplanationContainer" class="hidden mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm text-blue-800">
            <div id="trendExplanationContent" class="font-medium"></div>
        </div>
        
        <div id="trend-legend-container" class="trend-legend-container hidden"></div>

        <!-- New: Button to open Q&A Modal -->
        <div class="qna-trigger-section mt-4 text-center">
            <button id="openQAModalButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.76-1.39A8.968 8.968 0 005 15c-2.43 0-4.475-1.577-5-3 1.076-1.513 2.64-2.5 4.5-2.5 1.5 0 2.896.685 4 1.76V7.5a2.5 2.5 0 015 0v1.176c1.104-1.075 2.5-1.76 4-1.76 1.86 0 3.424.987 4.5 2.5-.525 1.423-2.57 3-5 3z" clip-rule="evenodd" />
                </svg>
                Hỏi & Đáp Hóa Học
            </button>
        </div>

    </div>
    
    <div id="statusMessage" class="status-message"></div>
    <div id="legend-container" class="legend-container"></div>

    <div class="container">
        <div class="periodic-table-wrapper" id="periodicTableWrapper"></div>
        <div class="f-block-wrapper">
            <div class="f-block-grid" id="lanthanidesBlock"></div>
            <div class="f-block-grid mt-2" id="actinidesBlock"></div>
        </div>
    </div>
    
    <div id="bottomSheetOverlay"></div>
    <div id="bottomSheet">
        <div class="bottom-sheet-header">
            <h3 id="detailElementName">Chọn một nguyên tố</h3>
            <button class="close-button" id="closeBottomSheet">X</button>
        </div>
        <div id="bottomSheetContent">
            <div id="geminiDetailContent"></div>
            <div id="geminiLoading" class="loading-spinner hidden">
                <div class="spinner"></div>
                <p class="ml-4 text-blue-600">Đang hỏi Gemini AI...</p>
            </div>
        </div>
    </div>

    <!-- New Q&A Modal Structure -->
    <div id="qnaModalOverlay" style="display: none;">
        <div id="qnaModal">
            <button class="close-button" id="closeQAModal">X</button>
            <h4>Hỏi & Đáp Hóa Học</h4>
            <textarea id="qnaQueryInput" placeholder="Ví dụ: Tại sao nước lại có tính phân cực?"></textarea>
            <button id="askAIButton">Hỏi AI</button>
            <div id="qnaResponseContainer" class="hidden">
                <div id="qnaLoading" class="loading-spinner">
                    <div class="spinner"></div>
                    <p class="ml-4 text-blue-600">Đang hỏi Gemini AI...</p>
                </div>
                <div id="qnaResponseContent"></div>
            </div>
        </div>
    </div>

    <div id="elementTooltip" class="element-tooltip"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";

        // --- DATA ---
        const firebaseConfig = { apiKey: "AIzaSyBsTFay_kTVzr2J50pxrAUdiuOBkwNSJHY", authDomain: "aith-c70eb.firebaseapp.com", projectId: "aith-c70eb", storageBucket: "aith-c70eb.firebasestorage.app", messagingSenderId: "556224999133", appId: "1:556224999133:web:a79ae0f22b612dc167b534" };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const trendData = {
            electronegativity: {1:2.2,2:null,3:0.98,4:1.57,5:2.04,6:2.55,7:3.04,8:3.44,9:3.98,10:null,11:0.93,12:1.31,13:1.61,14:1.9,15:2.19,16:2.58,17:3.16,18:null,19:0.82,20:1,21:1.36,22:1.54,23:1.63,24:1.66,25:1.55,26:1.83,27:1.88,28:1.91,29:1.9,30:1.65,31:1.81,32:2.01,33:2.18,34:2.55,35:2.96,36:3,37:0.82,38:0.95,39:1.22,40:1.33,41:1.6,42:2.16,43:1.9,44:2.2,45:2.28,46:2.2,47:1.93,48:1.69,49:1.78,50:1.96,51:2.05,52:2.1,53:2.66,54:2.6,55:0.79,56:0.89,57:1.1,58:1.12,59:1.13,60:1.14,61:1.13,62:1.17,63:1.2,64:1.2,65:1.2,66:1.22,67:1.23,68:1.24,69:1.25,70:1.1,71:1.27,72:1.3,73:1.5,74:2.36,75:1.9,76:2.2,77:2.2,78:2.28,79:2.54,80:2,81:1.62,82:2.33,83:2.02,84:2,85:2.2,86:2.6,87:0.7,88:0.9,89:1.1,90:1.3,91:1.5,92:1.38,93:1.36,94:1.28,95:1.3,96:1.3,97:1.3,98:1.3,99:1.3,100:1.3,101:1.3,102:1.3,103:null,104:null,105:null,106:null,107:null,108:null,109:null,110:null,111:null,112:null,113:null,114:null,115:null,116:null,117:null,118:null},
            ionizationEnergy: {1:1312,2:2372.3,3:520.2,4:899.5,5:800.6,6:1086.5,7:1402.3,8:1313.9,9:1681,10:2080.7,11:495.8,12:737.7,13:577.5,14:786.5,15:1011.8,16:999.6,17:1251.2,18:1520.6,19:418.8,20:589.8,21:633.1,22:658.8,23:650.9,24:652.9,25:717.3,26:762.5,27:760.4,28:737.1,29:745.5,30:906.4,31:578.8,32:762,33:947,34:941,35:1139.9,36:1350.8,37:403,38:549.5,39:600,40:640.1,41:652.1,42:684.3,43:702,44:710.2,45:719.7,46:804.4,47:731,48:867.8,49:558.3,50:708.6,51:834,52:869.3,53:1008.4,54:1170.4,55:375.7,56:502.9,57:538.1,58:534.4,59:527.4,60:533.1,61:540,62:544.5,63:547.1,64:593.4,65:565.8,66:573,67:581,68:589.3,69:596.7,70:603.4,71:523.5,72:654,73:761,74:770,75:760,76:840,77:880,78:870,79:890.1,80:1007.1,81:589.4,82:715.6,83:703,84:812.1,85:890,86:1037,87:380,88:509.3,89:490,90:587,91:568,92:597.6,93:604.5,94:584.7,95:578,96:581,97:601,98:608,99:619,100:627,101:635,102:642,103:null,104:null,105:null,106:null,107:null,108:null,109:null,110:null,111:null,112:null,113:null,114:null,115:null,116:null,117:null,118:null},
            atomicRadius: {1:53,2:31,3:167,4:112,5:87,6:67,7:56,8:48,9:42,10:38,11:190,12:145,13:118,14:111,15:98,16:88,17:79,18:71,19:243,20:194,21:184,22:176,23:171,24:166,25:161,26:156,27:152,28:149,29:145,30:142,31:136,32:125,33:114,34:103,35:94,36:88,37:265,38:219,39:200,40:186,41:189,42:190,43:183,44:178,45:173,46:169,47:165,48:161,49:156,50:145,51:133,52:123,53:115,54:108,55:298,56:253,57:207,58:204,59:206,60:205,61:203,62:202,63:208,64:199,65:196,66:194,67:192,68:190,69:187,70:185,71:185,72:187,73:180,74:180,75:180,76:170,77:170,78:160,79:150,80:150,81:190,82:170,83:160,84:150,85:140,86:130,87:null,88:215,89:195,90:180,91:175,92:170,93:165,94:160,95:180,96:null,97:null,98:null,99:null,100:null,101:null,102:null,103:null,104:null,105:null,106:null,107:null,108:null,109:null,110:null,111:null,112:null,113:null,114:null,115:null,116:null,117:null,118:null},
            atomicMasses: { 1:1.008,2:4.0026,3:6.94,4:9.0122,5:10.81,6:12.011,7:14.007,8:15.999,9:18.998,10:20.18,11:22.99,12:24.305,13:26.982,14:28.085,15:30.974,16:32.06,17:35.45,18:39.948,19:39.098,20:40.078,21:44.956,22:47.867,23:50.942,24:51.996,25:54.938,26:55.845,27:58.933,28:58.693,29:63.546,30:65.38,31:69.723,32:72.63,33:74.922,34:78.971,35:79.904,36:83.798,37:85.468,38:87.62,39:88.906,40:91.224,41:92.906,42:95.96,43:98,44:101.07,45:102.91,46:106.42,47:107.87,48:112.41,49:114.82,50:118.71,51:121.76,52:127.6,53:126.9,54:131.29,55:132.91,56:137.33,57:138.91,58:140.12,59:140.91,60:144.24,61:145,62:150.36,63:151.96,64:157.25,65:158.93,66:162.5,67:164.93,68:167.26,69:168.93,70:173.05,71:174.97,72:178.49,73:180.95,74:183.84,75:186.21,76:190.23,77:192.22,78:195.08,79:196.97,80:200.59,81:204.38,82:207.2,83:208.98,84:209,85:210,86:222,87:223,88:226,89:227,90:232.04,91:231.04,92:238.03,93:237,94:244,95:243,96:247,97:247,98:251,99:252,100:257,101:258,102:259,103:266,104:267,105:268,106:269,107:270,108:269,109:278,110:281,111:282,112:285,113:286,114:289,115:289,116:293,117:294,118:294 }
        };
        const colorGradients = {
            electronegativity: ['#ffffff', '#f44336'], // White to Red
            ionizationEnergy: ['#ffffff', '#2196f3'], // White to Blue
            atomicRadius: ['#ffffff', '#4caf50'], // White to Green
        };
        
        // --- GLOBAL STATE ---
        let app, auth, model;
        let elements = [];
        let currentTemperatureKelvin = 298;
        let activeGroupFilter = null;
        let activeTrend = 'none'; // 'none' or 'electronegativity', 'ionizationEnergy', 'atomicRadius'

        // --- DOM ELEMENTS ---
        const dom = {
            tableWrapper: document.getElementById('periodicTableWrapper'),
            lanthanidesBlock: document.getElementById('lanthanidesBlock'),
            actinidesBlock: document.getElementById('actinidesBlock'),
            searchInput: document.getElementById('searchInput'),
            kelvinInput: document.getElementById('kelvinInput'),
            trendsControl: document.getElementById('trends-control'),
            trendLegendContainer: document.getElementById('trend-legend-container'),
            legendContainer: document.getElementById('legend-container'),
            bottomSheet: document.getElementById('bottomSheet'),
            bottomSheetOverlay: document.getElementById('bottomSheetOverlay'),
            closeBottomSheetButton: document.getElementById('closeBottomSheet'),
            detailElementName: document.getElementById('detailElementName'),
            geminiDetailContent: document.getElementById('geminiDetailContent'),
            geminiLoading: document.getElementById('geminiLoading'),
            statusMessage: document.getElementById('statusMessage'),
            elementTooltip: document.getElementById('elementTooltip'),
            // Existing Trend Explanation DOM elements
            trendExplanationContainer: document.getElementById('trendExplanationContainer'),
            trendExplanationContent: document.getElementById('trendExplanationContent'),
            // New Q&A Modal DOM elements
            openQAModalButton: document.getElementById('openQAModalButton'),
            qnaModalOverlay: document.getElementById('qnaModalOverlay'),
            qnaModal: document.getElementById('qnaModal'),
            closeQAModal: document.getElementById('closeQAModal'),
            qnaQueryInput: document.getElementById('qnaQueryInput'),
            askAIButton: document.getElementById('askAIButton'),
            qnaResponseContainer: document.getElementById('qnaResponseContainer'),
            qnaLoading: document.getElementById('qnaLoading'),
            qnaResponseContent: document.getElementById('qnaResponseContent'),
        };

        // Map trend data-trend to Vietnamese display names
        const trendDisplayNames = {
            electronegativity: 'độ âm điện',
            ionizationEnergy: 'năng lượng ion hóa',
            atomicRadius: 'bán kính nguyên tử',
            none: 'tắt'
        };

        // Hardcoded trend explanations (for quick response)
        const hardcodedTrendExplanations = {
            electronegativity: `Độ âm điện là khả năng hút electron của nguyên tử trong liên kết hóa học. Xu hướng này tăng dần từ trái sang phải trong một chu kỳ do tăng lực hút hạt nhân và giảm dần từ trên xuống dưới trong một nhóm do tăng số lớp electron và hiệu ứng chắn. Ví dụ: Flo (F) là nguyên tố có độ âm điện cao nhất.`,
            ionizationEnergy: `Năng lượng ion hóa là năng lượng cần thiết để tách một electron ra khỏi nguyên tử ở trạng thái khí. Xu hướng này tăng dần từ trái sang phải trong một chu kỳ (electron bị giữ chặt hơn) và giảm dần từ trên xuống dưới trong một nhóm (bán kính nguyên tử và hiệu ứng chắn tăng, giảm lực hút hạt nhân). Ví dụ: Heli (He) có năng lượng ion hóa cao nhất.`,
            atomicRadius: `Bán kính nguyên tử là khoảng cách từ hạt nhân đến lớp electron ngoài cùng. Xu hướng này giảm dần từ trái sang phải trong một chu kỳ do lực hút hạt nhân tăng và tăng dần từ trên xuống dưới trong một nhóm do tăng số lớp electron. Ví dụ: Franci (Fr) có bán kính nguyên tử lớn nhất trong các nguyên tố đã biết.`
        };
        
        // --- CORE FUNCTIONS ---
        function augmentElementData(elements) {
            return elements.map(el => ({ 
                ...el, 
                atomic_mass: trendData.atomicMasses[el.number] || 0,
                electronegativity: trendData.electronegativity[el.number] || null,
                ionizationEnergy: trendData.ionizationEnergy[el.number] || null,
                atomicRadius: trendData.atomicRadius[el.number] || null,
            }));
        }

        function updateStatus(type, message) {
            dom.statusMessage.className = `status-message ${type}`;
            dom.statusMessage.textContent = message;
        }

        /**
         * Creates an element cell for the periodic table.
         * Attaches event listeners for clicks (bottom sheet) and hover (tooltip).
         * @param {object} element - The element data.
         * @returns {HTMLDivElement} The created element cell.
         */
        function createCell(element) {
            const cell = document.createElement('div');
            cell.className = `element-cell ${element.group}`;
            cell.dataset.number = element.number;
            cell.dataset.group = element.group;
            cell.innerHTML = `<span class="element-number">${element.number}</span><div class="element-symbol">${element.symbol}</div><div class="element-name">${element.name}</div><div class="element-mass">${element.atomic_mass > 0 ? element.atomic_mass.toFixed(3) : ''}</div>`;
            
            cell.addEventListener('click', () => handleElementClick(element));
            cell.addEventListener('mouseover', (e) => showTooltip(element, e));
            cell.addEventListener('mousemove', (e) => updateTooltipPosition(e));
            cell.addEventListener('mouseout', hideTooltip);

            return cell;
        }
        
        /**
         * Determines the physical state of an element at a given temperature.
         * @param {number} temperatureK - Temperature in Kelvin.
         * @param {number} meltingPointC - Melting point in Celsius.
         * @param {number} boilingPointC - Boiling point in Celsius.
         * @returns {string} 'solid', 'liquid', 'gas', or 'unknown'.
         */
        function getPhysicalState(temperatureK, meltingPointC, boilingPointC) {
            if (meltingPointC === null || boilingPointC === null) return 'unknown';
            const meltingK = meltingPointC + 273.15;
            const boilingK = boilingPointC + 273.15;
            if (temperatureK < meltingK) return 'solid';
            if (temperatureK >= meltingK && temperatureK < boilingK) return 'liquid';
            if (temperatureK >= boilingK) return 'gas';
            return 'unknown';
        }

        /**
         * Updates the physical state visual indicator for all elements based on current temperature.
         */
        function updateElementStates() {
            dom.kelvinInput.value = Math.round(currentTemperatureKelvin);
            elements.forEach(element => {
                const cell = document.querySelector(`.element-cell[data-number='${element.number}']`);
                if (!cell) return;
                const symbolDiv = cell.querySelector('.element-symbol');
                const state = getPhysicalState(currentTemperatureKelvin, element.melting_point_celsius, element.boiling_point_celsius);
                symbolDiv.classList.remove('state-solid', 'state-liquid', 'state-gas', 'state-unknown');
                symbolDiv.classList.add(`state-${state}`);
            });
        }
        
        // --- UI & EVENT HANDLERS ---

        /**
         * Handles search input, dimming elements not matching the query.
         * Clears other active filters/trends/Q&A modals.
         */
        function handleSearch() {
            resetAllVisualFilters();
            dom.trendExplanationContainer.classList.add('hidden');
            // Ensure Q&A modal is hidden
            dom.qnaModalOverlay.style.display = 'none';

            const query = dom.searchInput.value.toLowerCase().trim();
            
            document.querySelectorAll('.element-cell[data-number]').forEach(cell => {
                if (!query) {
                    cell.classList.remove('dimmed');
                    return;
                }
                const element = elements.find(el => el.number == cell.dataset.number);
                if (!element) return;
                
                const name = element.name.toLowerCase();
                const symbol = element.symbol.toLowerCase();
                const number = element.number.toString();

                let isMatch;
                if (query.length <= 2) {
                    isMatch = (symbol === query || number === query);
                } else {
                    isMatch = name.includes(query);
                }
                
                cell.classList.toggle('dimmed', !isMatch);
            });
        }
        
        /**
         * Handles clicks on legend items to filter elements by group.
         * Clears other active filters/trends/Q&A modals.
         * @param {Event} event - The click event.
         */
        function handleLegendClick(event) {
            const clickedItem = event.target.closest('.legend-item');
            if (!clickedItem) return;

            resetAllVisualFilters();
            dom.searchInput.value = '';
            dom.trendExplanationContainer.classList.add('hidden');
            // Ensure Q&A modal is hidden
            dom.qnaModalOverlay.style.display = 'none';

            const group = clickedItem.dataset.group;
            
            if (activeGroupFilter === group) {
                activeGroupFilter = null;
                clickedItem.classList.remove('selected');
            } else {
                document.querySelector('.legend-item.selected')?.classList.remove('selected');
                activeGroupFilter = group;
                clickedItem.classList.add('selected');
            }
            applyGroupFilter();
        }

        /**
         * Handles clicks on trend buttons to visualize periodic trends and display explanations.
         * Clears other active filters/trends/Q&A modals.
         * @param {Event} event - The click event.
         */
        function handleTrendClick(event) {
            const clickedItem = event.target.closest('.trend-button');
            if (!clickedItem) return;
            
            resetAllVisualFilters();
            dom.searchInput.value = '';
            // Ensure Q&A modal is hidden
            dom.qnaModalOverlay.style.display = 'none';

            const trend = clickedItem.dataset.trend;
            activeTrend = trend;
            applyTrendVisualization(); // Apply visual trend (colors)

            if (activeTrend === 'none') {
                dom.trendExplanationContainer.classList.add('hidden'); // Hide explanation if 'none' is selected
            } else {
                dom.trendExplanationContainer.classList.remove('hidden'); // Show container
                explainTrendHardcoded(activeTrend); // Use hardcoded explanation
            }
        }

        /**
         * Applies the active group filter to dim non-matching elements.
         */
        function applyGroupFilter() {
            document.querySelectorAll('.element-cell[data-number]').forEach(cell => {
                const element = elements.find(el => el.number == cell.dataset.number);
                if(!element) return;
                cell.classList.toggle('dimmed', activeGroupFilter && element.group !== activeGroupFilter);
            });
        }
        
        // --- TREND VISUALIZATION ---
        /**
         * Applies color visualization based on the selected periodic trend.
         */
        function applyTrendVisualization() {
            document.querySelectorAll('.trend-button').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.trend === activeTrend);
            });
        
            if (activeTrend === 'none') {
                resetElementBackgrounds();
                dom.trendLegendContainer.classList.add('hidden');
                return;
            }

            const validElements = elements.filter(el => el[activeTrend] !== null);
            if (validElements.length === 0) return;

            const values = validElements.map(el => el[activeTrend]);
            const minVal = Math.min(...values);
            const maxVal = Math.max(...values);
            const gradient = colorGradients[activeTrend];

            elements.forEach(el => {
                const cell = document.querySelector(`.element-cell[data-number='${el.number}']`);
                if (!cell) return;

                const value = el[activeTrend];
                if (value === null) {
                    cell.className = 'element-cell no-data';
                } else {
                    cell.className = `element-cell ${el.group}`;
                    const color = mapValueToColor(value, minVal, maxVal, gradient[0], gradient[1]);
                    cell.style.backgroundColor = color;
                    cell.style.borderColor = color;
                }
            });

            dom.trendLegendContainer.innerHTML = `
                <span>${minVal}</span>
                <div class="trend-legend-gradient" style="background: linear-gradient(to right, ${gradient[0]}, ${gradient[1]})"></div>
                <span>${maxVal}</span>
            `;
            dom.trendLegendContainer.classList.remove('hidden');
        }

        /**
         * Resets all element cell backgrounds to their default group colors.
         */
        function resetElementBackgrounds() {
             elements.forEach(el => {
                const cell = document.querySelector(`.element-cell[data-number='${el.number}']`);
                if (!cell) return;
                cell.className = `element-cell ${el.group}`;
                cell.style.backgroundColor = '';
                cell.style.borderColor = '';
            });
        }
        
        /**
         * Maps a numeric value to a color within a given gradient.
         * @param {number} value - The value to map.
         * @param {number} min - Minimum value in the range.
         * @param {number} max - Maximum value in the range.
         * @param {string} color1 - Starting hex color (e.g., '#ffffff').
         * @param {string} color2 - Ending hex color (e.g., '#f44336').
         * @returns {string} RGB color string.
         */
        function mapValueToColor(value, min, max, color1, color2) {
            const percent = (value - min) / (max - min);
            const hexToRgb = (hex) => hex.match(/\w\w/g).map(c => parseInt(c, 16));
            const [r1, g1, b1] = hexToRgb(color1.substring(1));
            const [r2, g2, b2] = hexToRgb(color2.substring(1));
            const r = Math.round(r1 + percent * (r2 - r1));
            const g = Math.round(g1 + percent * (g2 - g1));
            const b = Math.round(b1 + percent * (b2 - b1));
            return `rgb(${r},${g},${b})`;
        }

        // --- TOOLTIP FUNCTIONS ---
        /**
         * Displays a tooltip with basic element information on hover.
         * @param {object} element - The element data.
         * @param {MouseEvent} event - The mouse event.
         */
        function showTooltip(element, event) {
            const state = getPhysicalState(currentTemperatureKelvin, element.melting_point_celsius, element.boiling_point_celsius);
            const stateTextMap = {
                solid: 'Rắn',
                liquid: 'Lỏng',
                gas: 'Khí',
                unknown: 'Không xác định'
            };
            const displayState = stateTextMap[state] || 'Không xác định';

            const cellElement = event.target.closest('.element-cell');
            const computedStyle = window.getComputedStyle(cellElement);
            const cellBgColor = computedStyle.backgroundColor;
            const cellBorderColor = computedStyle.borderColor;

            dom.elementTooltip.style.backgroundColor = cellBgColor;
            dom.elementTooltip.style.borderColor = cellBorderColor;
            dom.elementTooltip.style.color = '#000000'; // Set tooltip text color to black

            dom.elementTooltip.innerHTML = `
                <p><strong>Số nguyên tử:</strong> ${element.number}</p>
                <p><strong>Ký hiệu:</strong> ${element.symbol}</p>
                <p><strong>Tên:</strong> ${element.name}</p>
                <p><strong>Khối lượng NT:</strong> ${element.atomic_mass > 0 ? element.atomic_mass.toFixed(3) : 'N/A'} amu</p>
                <p><strong>Trạng thái (${Math.round(currentTemperatureKelvin)}K):</strong> ${displayState}</p>
            `;
            dom.elementTooltip.classList.add('visible');
            updateTooltipPosition(event);
        }

        /**
         * Updates the tooltip's position to follow the mouse cursor, ensuring it stays within viewport.
         * @param {MouseEvent} event - The mouse event.
         */
        function updateTooltipPosition(event) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const tooltipRect = dom.elementTooltip.getBoundingClientRect();

            let x = event.clientX + 15;
            let y = event.clientY + 15;

            if (x + tooltipRect.width > viewportWidth - 20) {
                x = event.clientX - tooltipRect.width - 15;
                if (x < 20) {
                    x = viewportWidth - tooltipRect.width - 20;
                }
            }
            if (y + tooltipRect.height > viewportHeight - 20) {
                y = event.clientY - tooltipRect.height - 15;
                if (y < 20) {
                    y = viewportHeight - tooltipRect.height - 20;
                }
            }

            if (x < 0) x = 0;
            if (y < 0) y = 0;

            dom.elementTooltip.style.left = `${x}px`;
            dom.elementTooltip.style.top = `${y}px`;
        }

        /**
         * Hides the element tooltip.
         */
        function hideTooltip() {
            dom.elementTooltip.classList.remove('visible');
        }

        // --- HARDCODED TREND EXPLANATION FUNCTION ---
        /**
         * Displays hardcoded explanations for periodic trends.
         * @param {string} trend - The selected trend key (e.g., 'electronegativity').
         */
        function explainTrendHardcoded(trend) {
            const explanation = hardcodedTrendExplanations[trend];
            if (explanation) {
                dom.trendExplanationContent.innerHTML = `<p>${explanation}</p>`;
                updateStatus('success-text', `Đã nhận giải thích về xu hướng ${trendDisplayNames[trend]}.`);
            } else {
                dom.trendExplanationContent.innerHTML = `<p class="text-red-500">Không có giải thích cho xu hướng này.</p>`;
                updateStatus('error-text', `Không tìm thấy giải thích.`);
            }
        }

        /**
         * Resets all visual filters (search, group, trend) on the periodic table.
         * Brings all elements back to their default, undimmed state with group colors.
         */
        function resetAllVisualFilters() {
            // Reset search input and dimming
            dom.searchInput.value = '';
            document.querySelectorAll('.element-cell[data-number]').forEach(cell => {
                cell.classList.remove('dimmed');
                cell.style.backgroundColor = ''; // Reset background if trend was active
                cell.style.borderColor = '';     // Reset border if trend was active
            });

            // Reset group filter selection
            if (activeGroupFilter) {
                document.querySelector('.legend-item.selected')?.classList.remove('selected');
                activeGroupFilter = null;
            }

            // Reset trend buttons and visualization
            document.querySelectorAll('.trend-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            activeTrend = 'none';
            dom.trendLegendContainer.classList.add('hidden');
            dom.trendExplanationContainer.classList.add('hidden'); // Hide trend explanation

            // Ensure Q&A modal is hidden and its content cleared
            dom.qnaModalOverlay.style.display = 'none';
            dom.qnaQueryInput.value = '';
            dom.qnaResponseContent.innerHTML = '';
            dom.qnaResponseContainer.classList.add('hidden'); // Hide response container

            resetElementBackgrounds(); // Ensure all backgrounds are back to default group colors
        }

        // --- Q&A MODAL FUNCTIONS (NEW) ---

        /**
         * Opens the Q&A modal, clearing previous content.
         */
        function openQAModal() {
            dom.qnaModalOverlay.style.display = 'flex'; // Show modal
            dom.qnaQueryInput.value = ''; // Clear input field
            dom.qnaResponseContent.innerHTML = ''; // Clear previous response
            dom.qnaResponseContainer.classList.add('hidden'); // Hide response container until asked
            dom.qnaLoading.classList.add('hidden'); // Hide loading initially
        }

        /**
         * Closes the Q&A modal and resets visual filters.
         */
        function closeQAModal() {
            dom.qnaModalOverlay.style.display = 'none'; // Hide modal
            resetAllVisualFilters(); // Reset table state when closing modal
        }

        /**
         * Handles the user's question to the AI.
         * @returns {Promise<void>}
         */
        async function handleAskAI() {
            const query = dom.qnaQueryInput.value.trim();
            if (!query) {
                dom.qnaResponseContainer.classList.remove('hidden');
                dom.qnaResponseContent.innerHTML = `<p class="text-red-500">Vui lòng nhập câu hỏi của bạn.</p>`;
                return;
            }

            dom.qnaResponseContainer.classList.remove('hidden');
            dom.qnaResponseContent.innerHTML = ''; // Clear previous response
            dom.qnaLoading.classList.remove('hidden'); // Show loading spinner

            if (!model) {
                dom.qnaLoading.classList.add('hidden');
                dom.qnaResponseContent.innerHTML = `<p class="text-red-500">Lỗi: Mô hình AI chưa được khởi tạo. Vui lòng đợi thông báo "AI đã sẵn sàng" hoặc kiểm tra lại.</p>`;
                updateStatus('error-text', 'Mô hình AI chưa sẵn sàng. Chức năng Hỏi & Đáp sẽ không hoạt động.');
                return;
            }

            try {
                updateStatus('info-text', `Đang hỏi AI: "${query}"...`);
                
                // Prompt for general chemistry Q&A
                const promptText = `Người dùng hỏi: "${query}". Vui lòng trả lời câu hỏi này về hóa học hoặc các nguyên tố bảng tuần hoàn một cách chi tiết, chính xác và dễ hiểu. Sử dụng định dạng Markdown nếu cần để làm rõ các điểm. Trả lời bằng tiếng Việt.`;
                
                const result = await model.generateContent(promptText);
                const text = result.response.text();
                
                dom.qnaResponseContent.innerHTML = `<div style="font-size: 1.6rem; line-height: 1.7;">${window.marked.parse(text)}</div>`;
                updateStatus('success-text', `Đã nhận câu trả lời từ AI.`);

            } catch (error) {
                console.error("Lỗi khi gọi Gemini API cho Hỏi & Đáp:", error);
                dom.qnaResponseContent.innerHTML = `<p class="text-red-500">Lỗi khi hỏi AI: ${error.message}. Vui lòng thử lại.</p>`;
                updateStatus('error-text', `Lỗi AI khi Hỏi & Đáp.`);
            } finally {
                dom.qnaLoading.classList.add('hidden'); // Hide loading spinner
                setTimeout(() => {
                    if (!dom.statusMessage.textContent.includes('Lỗi')) {
                        updateStatus('success-text', 'Mô hình AI đã sẵn sàng. Hãy chọn một nguyên tố hoặc đặt câu hỏi!');
                    }
                }, 4000);
            }
        }


        // --- UI CREATION ---
        /**
         * Creates the main periodic table and f-block grids.
         */
        function createUIGrids() {
            dom.tableWrapper.innerHTML = '';
            const grid = Array(7).fill(null).map(() => Array(18).fill(null));
            elements.forEach(el => {
                if (el.row > 7 || el.col > 18) return;
                if (el.group === 'lanthanide') {
                    if (!grid[5][2]) grid[5][2] = { type: 'ref', class: 'lanthanide-ref', text: '57-71' };
                } else if (el.group === 'actinide') {
                    if (!grid[6][2]) grid[6][2] = { type: 'ref', class: 'actinide-ref', text: '89-103' };
                } else {
                    grid[el.row - 1][el.col - 1] = { type: 'element', data: el };
                }
            });

            for (let r = 0; r < 7; r++) {
                const periodNum = document.createElement('div');
                periodNum.className = 'period-number';
                periodNum.textContent = r + 1;
                dom.tableWrapper.appendChild(periodNum);
                const rowGrid = document.createElement('div');
                rowGrid.className = 'periodic-table-grid';
                rowGrid.style.gridRow = r + 1;
                for (let c = 0; c < 18; c++) {
                    const cellData = grid[r][c];
                    const cellEl = document.createElement('div');
                    if (cellData) {
                        if (cellData.type === 'element') {
                             rowGrid.appendChild(createCell(cellData.data));
                        } else {
                             cellEl.className = `element-cell ${cellData.class}`;
                             cellEl.textContent = cellData.text;
                             rowGrid.appendChild(cellEl);
                        }
                    } else {
                       cellEl.className = 'empty-cell';
                       rowGrid.appendChild(cellEl);
                    }
                }
                dom.tableWrapper.appendChild(rowGrid);
            }
            dom.lanthanidesBlock.innerHTML = `<div class="period-number">6</div> <div></div> <div class="f-block-table" id="lanthanides-inner-grid"></div>`;
            dom.actinidesBlock.innerHTML = `<div class="period-number">7</div> <div></div> <div class="f-block-table" id="actinides-inner-grid"></div>`;
            const lanthGrid = document.getElementById('lanthanides-inner-grid');
            const actiGrid = document.getElementById('actinides-inner-grid');
            elements.filter(el => el.group === 'lanthanide').sort((a,b) => a.number - b.number).forEach(el => lanthGrid.appendChild(createCell(el)));
            elements.filter(el => el.group === 'actinide').sort((a,b) => a.number - b.number).forEach(el => actiGrid.appendChild(createCell(el)));
        }

        /**
         * Creates the top legend for element groups.
         */
        function createTopLegend() {
            const legendData = [
                { class: 'alkali-metal', text: 'Kim loại kiềm' }, { class: 'alkaline-earth-metal', text: 'Kim loại kiềm thổ' },
                { class: 'transition-metal', text: 'Kim loại chuyển tiếp' }, { class: 'post-transition-metal', text: 'Kim loại sau CT' },
                { class: 'lanthanide', text: 'Họ Lantan' }, { class: 'actinide', text: 'Họ Actini' }, { class: 'metalloid', text: 'Á kim' },
                { class: 'other-nonmetal', text: 'Phi kim khác' }, { class: 'halogen', text: 'Halogen' }, { class: 'noble-gas', text: 'Khí hiếm' },
            ];
            dom.legendContainer.innerHTML = '';
            legendData.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.className = `legend-item ${item.class}`;
                legendItem.textContent = item.text;
                legendItem.dataset.group = item.class;
                dom.legendContainer.appendChild(legendItem);
            });
        }
        
        // --- INITIALIZATION ---
        /**
         * Handles the click on an element cell, showing the detailed bottom sheet.
         * Fetches detailed information from Gemini AI.
         * @param {object} element - The element data clicked.
         */
        async function handleElementClick(element) {
            dom.bottomSheet.classList.add('active');
            dom.bottomSheetOverlay.style.display = 'block';
            
            dom.detailElementName.textContent = `${element.name} (${element.symbol})`;
            
            dom.geminiDetailContent.innerHTML = '';
            dom.geminiLoading.classList.remove('hidden');

            hideTooltip();

            if (!model) {
                 dom.geminiDetailContent.innerHTML = `<p class="text-red-500 mt-4">Lỗi: Mô hình AI chưa được khởi tạo. Vui lòng đợi thông báo "AI đã sẵn sàng" hoặc kiểm tra lại.</p>`;
                 dom.geminiLoading.classList.add('hidden');
                 return;
            }

            try {
                const promptText = `Cung cấp thông tin chi tiết về nguyên tố hóa học ${element.name} (ký hiệu ${element.symbol}, số nguyên tử ${element.number}). Vui lòng bao gồm:\n- Cấu hình electron\n- Độ âm điện\n- Trạng thái ở điều kiện tiêu chuẩn\n- Điểm nóng chảy và điểm sôi (Celsius)\n- Lịch sử phát hiện (ngắn gọn)\n- Ứng dụng phổ biến (dạng danh sách)\nVui lòng trả lời dưới dạng văn bản có cấu trúc với các mục rõ ràng sử dụng định dạng Markdown. Sử dụng ngôn ngữ tiếng Việt.`;
                updateStatus('info-text', `Đang hỏi Gemini về ${element.name}...`);
                const result = await model.generateContent(promptText);
                const text = result.response.text();

                const basicInfoHtml = `
                    <p><strong>Số nguyên tử:</strong> ${element.number}</p>
                    <p><strong>Ký hiệu:</strong> ${element.symbol}</p>
                    <p><strong>Khối lượng nguyên tử:</strong> ${element.atomic_mass.toFixed(3)} amu</p>
                    <hr class="my-4 border-t border-blue-200">
                `;
                
                dom.geminiDetailContent.innerHTML = basicInfoHtml + `<div style="font-size: 1.6rem; line-height: 1.7;" class="text-gray-800 mt-4">${window.marked.parse(text)}</div>`;
                updateStatus('success-text', `Đã nhận thông tin về ${element.name}.`);
            } catch (error) {
                console.error("Lỗi khi gọi Gemini API:", error);
                const errorHtml = `
                    <p><strong>Số nguyên tử:</strong> ${element.number}</p>
                    <p><strong>Ký hiệu:</strong> ${element.symbol}</p>
                    <p><strong>Khối lượng nguyên tử:</strong> ${element.atomic_mass.toFixed(3)} amu</p>
                    <hr class="my-4 border-t border-red-200">
                    <p class="text-red-500 mt-4"><strong>Lỗi khi lấy thông tin từ Gemini AI:</strong><br>${error.message}</p>`;
                dom.geminiDetailContent.innerHTML = errorHtml;
                updateStatus('error-text', `Lỗi Gemini API.`);
            } finally {
                dom.geminiLoading.classList.add('hidden');
                setTimeout(() => updateStatus('success-text', 'Mô hình AI đã sẵn sàng. Hãy chọn một nguyên tố!'), 4000);
            }
        }
        
        /**
         * Initializes Firebase and Gemini AI model.
         */
        async function initializeFirebaseAndAI() {
             try {
                updateStatus('info-text', 'Đang khởi tạo Firebase & AI...');
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                
                let authSuccess = false;
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                        authSuccess = true;
                        console.log("Đăng nhập bằng custom token thành công.");
                    } catch (tokenError) {
                        console.error("Lỗi custom token (sẽ thử đăng nhập ẩn danh):", tokenError);
                    }
                }

                if (!authSuccess) {
                    try {
                       await signInAnonymously(auth);
                       authSuccess = true;
                       console.log("Đăng nhập ẩn danh thành công.");
                    } catch (anonymousError) {
                        console.error("Lỗi đăng nhập ẩn danh:", anonymousError);
                        throw anonymousError;
                    }
                }
                
                const ai = getAI(app, { backend: new GoogleAIBackend() });
                model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
                console.log("Thể hiện Generative Model đã tạo!");
                updateStatus('success-text', 'Mô hình AI đã sẵn sàng. Hãy chọn một nguyên tố hoặc đặt câu hỏi!');
            } catch(e) {
                console.error("Lỗi cuối cùng khi khởi tạo AI:", e);
                updateStatus('error-text', `Lỗi khởi tạo AI. Chức năng AI sẽ không hoạt động.`);
            }
        }

        /**
         * Main function to initialize the application.
         */
        async function main() {
            try {
                updateStatus('info-text', 'Đang tải dữ liệu bảng tuần hoàn...');
                const response = await fetch('https://minhvtv4.github.io/aihoa/elements.json');
                if (!response.ok) throw new Error(`Lỗi HTTP! trạng thái: ${response.status}`);
                const rawElements = await response.json();
                elements = augmentElementData(rawElements);
                createTopLegend();
                createUIGrids();
                updateElementStates();
            } catch (error) {
                console.error("Lỗi khi tải dữ liệu ban đầu:", error);
                document.body.innerHTML = `<p class="text-red-500 text-center mt-10">Không thể tải dữ liệu bảng tuần hoàn. Vui lòng thử lại.</p>`;
                updateStatus('error-text', 'Tải dữ liệu thất bại.');
                return;
            }
            
            // Setup Listeners for controls
            dom.searchInput.addEventListener('input', handleSearch);
            dom.legendContainer.addEventListener('click', handleLegendClick);
            dom.trendsControl.addEventListener('click', handleTrendClick);
            dom.kelvinInput.addEventListener('change', () => { 
                currentTemperatureKelvin = parseFloat(dom.kelvinInput.value) || 298; 
                updateElementStates(); 
            });

            // Setup Listeners for bottom sheet
            dom.closeBottomSheetButton.addEventListener('click', () => { 
                dom.bottomSheet.classList.remove('active'); 
                dom.bottomSheetOverlay.style.display = 'none'; 
            });
            dom.bottomSheetOverlay.addEventListener('click', () => dom.closeBottomSheetButton.click());

            // Setup Listeners for Q&A modal
            dom.openQAModalButton.addEventListener('click', openQAModal);
            dom.closeQAModal.addEventListener('click', closeQAModal);
            dom.qnaModalOverlay.addEventListener('click', (e) => {
                // Close modal if clicking outside the modal content
                if (e.target === dom.qnaModalOverlay) {
                    closeQAModal();
                }
            });
            dom.askAIButton.addEventListener('click', handleAskAI);


            // Initialize Firebase and AI services
            await initializeFirebaseAndAI();
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>

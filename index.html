<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine Hóa học AI v3.0 - Nhà Hóa học AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Variables CSS for easy color management */
        :root {
            --dark-bg: #111827;
            --light-bg: #1f2937;
            --panel-bg: #374151;
            --accent-color: #8b5cf6; /* Accent purple color */
            --danger-color: #ef4444; /* Red color for errors */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e5e7eb; /* Light text color */
            padding: 1rem; /* Overall padding */
        }
        .simulation-container {
            width: 95vw;
            max-width: 1000px;
            background: var(--light-bg);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column; /* Arrange elements vertically */
            gap: 1rem; /* Space between elements */
        }
        /* Add text shadow effect to the title */
        h1 {
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
            transition: text-shadow 0.3s ease-in-out;
        }
        h1:hover {
            text-shadow: 0 0 25px rgba(139, 92, 246, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #reaction-chamber {
            position: relative;
            width: 100%;
            height: 500px; /* Fixed height for the reaction chamber */
            background: var(--dark-bg);
            border-radius: 1rem;
            overflow: hidden; /* Ensure content doesn't overflow */
            cursor: grab; /* Grab cursor */
            display: flex; /* Use flexbox to center WebGL error content */
            justify-content: center;
            align-items: center;
        }
        #reaction-chamber canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* New: Style for the drag hint */
        #drag-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.1rem;
            font-weight: 500;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease-in-out;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10; /* Ensure it's above canvas */
        }
        #drag-hint.show {
            opacity: 1;
        }

        .ui-panel {
            background: var(--panel-bg);
            border-radius: 1rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        /* Update style for textarea */
        #equation-input {
            flex-grow: 1; /* Allow textarea to expand */
            background: var(--light-bg);
            border: 1px solid var(--accent-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #fff;
            outline: none; /* Remove default outline */
            transition: border-color 0.3s; /* Border color transition */
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px; /* Minimum height */
        }
        #equation-input:focus {
            border-color: #a78bfa; /* Border color on focus */
        }
        /* New class for error state */
        #equation-input.input-error {
            border-color: var(--danger-color);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.5); /* Red shadow for error */
        }

        .main-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease; /* Smooth transition effect */
            font-weight: 600;
            display: flex; /* Use flexbox to center spinner and text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .main-btn:hover {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            transform: translateY(-2px); /* Slight lift effect */
        }
        .main-btn:disabled {
            background-image: none;
            background-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #controls-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            justify-content: center; /* Center align buttons */
        }
        .icon-btn {
            background: transparent;
            border: 1px solid #6b7280;
            color: #d1d5db;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2rem;
        }
        .icon-btn:hover {
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }
        .icon-btn:disabled {
            color: #6b7280;
            border-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Add style for speed and timeline sliders */
        .speed-control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem; /* Space below progress bar */
        }
        .speed-btn {
            background-color: var(--panel-bg);
            color: #e5e7eb;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            border: 1px solid #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        .speed-btn:hover:not(.active) {
            border-color: var(--accent-color);
            color: white;
        }
        .speed-btn.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }
        .speed-btn:disabled {
            background-color: #4b5563;
            border-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }

        #timeline-slider {
            width: 100%;
            -webkit-appearance: none; /* Hide default appearance */
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            margin-top: 1rem; /* Space from control buttons */
        }
        #timeline-slider:hover {
            opacity: 1;
        }
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }


        #progress-container {
            flex-grow: 1;
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            overflow: hidden;
            display: none; /* Hide old progress bar, replaced by new slider */
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 99px;
            transition: width 0.3s ease; /* Transition effect for progress bar */
        }
        /* Update style for info-text to act like a toast */
        #info-text {
            text-align: center;
            min-height: 24px; /* Maintain space to prevent layout shift */
            color: #e5e7eb;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out, color 0.3s ease-in-out; /* Transition effect */
            font-size: 1rem; /* Increase font size */
            font-weight: 600; /* Increase font weight */
        }
        #info-text.error-message {
            color: var(--danger-color); /* Red color for errors */
        }

        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* WebGL Error message */
        .webgl-error-message {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--danger-color); /* Red background for errors */
            color: white;
            border-radius: 0.75rem;
            font-size: 1rem;
            max-width: 80%;
        }
        .webgl-error-message h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .webgl-error-message p {
            margin-bottom: 0.5rem;
        }
        .webgl-error-message a {
            color: #fee2e2;
            text-decoration: underline;
        }
        .webgl-error-message a:hover {
            color: #fff;
        }

        /* New: CSS for Welcome Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .welcome-modal {
            background-color: var(--panel-bg);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.show .welcome-modal {
            transform: scale(1);
        }
        .welcome-modal h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }
        .welcome-modal p {
            font-size: 1rem;
            line-height: 1.5;
            color: #d1d5db;
            margin-bottom: 1.5rem;
        }
        .modal-close-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        .modal-close-btn:hover {
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.6);
            transform: translateY(-3px);
        }

        /* NEW: Styles for Atom Legend */
        .atom-legend {
            background-color: var(--light-bg);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            margin-top: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .atom-legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
            font-weight: 600;
            color: var(--accent-color);
        }
        .atom-legend-header:hover {
            color: #a78bfa;
        }
        .atom-legend-toggle {
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 0.2s ease-in-out;
        }
        .atom-legend-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            display: grid; /* Use grid for layout */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive columns */
            gap: 0.5rem;
            padding-top: 0; /* Initially no padding */
        }
        .atom-legend-content.expanded {
            max-height: 200px; /* Max height when expanded (adjust as needed) */
            overflow-y: auto; /* Enable scrolling if content overflows */
            padding-top: 0.75rem; /* Add padding when expanded */
        }
        .atom-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
        }
        .atom-color-circle {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0; /* Prevent circle from shrinking */
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <h1 class="text-2xl font-bold text-center mb-4">Nhà Hóa học AI v3.0</h1>
        <div id="reaction-chamber">
            <!-- WebGL error message will be inserted here if needed -->
            <!-- New: Drag hint for 3D interaction -->
            <div id="drag-hint">Kéo để xoay</div>
        </div>
        <div class="ui-panel">
            <div class="input-group">
                <textarea id="equation-input" rows="3" placeholder="Nhập các chất tham gia (vd: H2 + O2), hoặc phương trình (vd: 2H2 + O2 -> 2H2O), hoặc mô tả (vd: Phản ứng đốt cháy Metan)..."></textarea>
                <button id="generate-btn" class="main-btn">
                    Tạo Phản ứng
                    <div id="loading-spinner" class="spinner hidden"></div>
                </button>
            </div>
             <div id="controls-bar">
                <button id="play-pause-btn" class="icon-btn" disabled>▶️</button>
                <button id="restart-btn" class="icon-btn" disabled>🔄</button>
                
                <div class="speed-control-group">
                    <button class="speed-btn" data-speed="0.5" disabled>0.5x</button>
                    <button class="speed-btn active" data-speed="1" disabled>1x</button>
                    <button class="speed-btn" data-speed="2" disabled>2x</button>
                </div>

                <div id="progress-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <input type="range" id="timeline-slider" min="0" max="100" value="0" disabled>

            <!-- NEW: Atom Color Legend Section -->
            <div id="atom-legend" class="atom-legend">
                <div class="atom-legend-header" id="atom-legend-header">
                    <span>Chú thích màu nguyên tử</span>
                    <span class="atom-legend-toggle">▼</span>
                </div>
                <div class="atom-legend-content" id="atom-legend-content">
                    <!-- Atom items will be dynamically inserted here -->
                </div>
            </div>

            <p id="info-text">Hãy xem AI dự đoán và diễn họa phản ứng hóa học!</p>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div id="welcome-modal-overlay" class="modal-overlay">
        <div class="welcome-modal">
            <h2>Chào mừng đến với Nhà Hóa học AI v3.0!</h2>
            <p>Khám phá thế giới hóa học sống động với sức mạnh của AI.</p>
            <p>Nhập các chất tham gia hoặc một phương trình hóa học vào ô bên dưới, sau đó nhấn "Tạo Phản ứng" để xem AI diễn họa quá trình!</p>
            <p>Bạn cũng có thể kéo để xoay buồng phản ứng 3D và sử dụng các điều khiển bên dưới để tùy chỉnh hoạt ảnh.</p>
            <button id="modal-close-btn" class="modal-close-btn">Bắt đầu ngay!</button>
        </div>
    </div>

    <!-- Imports -->
    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/" } }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Firebase, AI, 3D Engine Setup ---
        const firebaseConfig = { apiKey: "AIzaSyBVpguEIjTnIVOk1Ld0u-BGC7nM-pSww_o", authDomain: "aihoa-ac63b.firebaseapp.com", projectId: "aihoa-ac63b", storageBucket: "aihoa-ac63b.firebasestorage.app", messagingSenderId: "241068548961", appId: "1:241068548961:web:33d4126d020e9372d15b20"};
        let model;
        try {
            const app = initializeApp(firebaseConfig);
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            // Use gemini-2.5-flash for content generation
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        } catch (e) {
            console.error("Firebase/AI initialization error:", e);
            // Display error if AI cannot be initialized
            displayMessage("Lỗi: Không thể kết nối với AI Engine. Vui lòng kiểm tra console để biết chi tiết.", true);
            document.getElementById('generate-btn').disabled = true;
        }

        const chamber = document.getElementById('reaction-chamber');
        let renderer, scene, camera, controls, composer, mainTimeline;
        let molecules = [];
        let particles;

        function init3D() {
            chamber.innerHTML = ''; // Clear old WebGL error content if any
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, chamber.clientWidth / chamber.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                chamber.appendChild(renderer.domElement);

                // Setup Post-processing (Bloom effect)
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                const outputPass = new OutputPass();

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
                composer.addPass(outputPass);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                camera.position.z = 15;

                // OrbitControls for camera interaction
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Add particle system
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const particleColor = new THREE.Color(0xffffff); // White color
                const sphereRadius = 20; // Radius of the particle distribution area

                for (let i = 0; i < particleCount; i++) {
                    // Generate random positions within a sphere
                    const x = (Math.random() - 0.5) * 2 * sphereRadius;
                    const y = (Math.random() - 0.5) * 2 * sphereRadius;
                    const z = (Math.random() - 0.5) * 2 * sphereRadius;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // Assign white color with slight opacity
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                }

                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1, // Particle size
                    vertexColors: true, // Use colors from attribute
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending // Additive blending for brighter particles
                });

                particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                particles.visible = true; // Show particles by default

                // Main animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    // Rotate particles gently
                    if (particles && particles.visible) {
                        particles.rotation.y += 0.0005;
                        particles.rotation.x += 0.0002;
                    }
                    composer.render();
                }
                animate();

                // Listen for window resize events
                window.addEventListener('resize', () => {
                    camera.aspect = chamber.clientWidth / chamber.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                    composer.setSize(chamber.clientWidth, chamber.clientHeight);
                });

            } catch (error) {
                console.error("WebGL initialization error:", error);
                // Display more user-friendly error message
                chamber.innerHTML = `
                    <div class="webgl-error-message">
                        <h2>Lỗi WebGL</h2>
                        <p>Trình duyệt của bạn có thể không hỗ trợ hoặc WebGL đang bị tắt.</p>
                        <p>Để trải nghiệm hoạt ảnh 3D, vui lòng đảm bảo trình duyệt của bạn được cập nhật và WebGL được bật.</p>
                        <p><a href="https://get.webgl.org/" target="_blank">Kiểm tra trạng thái WebGL của bạn tại đây</a></p>
                    </div>
                `;
                generateBtn.disabled = true;
                throw new Error("WebGL init failed");
            }
        }

        // --- Core Application Logic ---
        const generateBtn = document.getElementById('generate-btn');
        const input = document.getElementById('equation-input');
        const infoText = document.getElementById('info-text');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const speedButtons = document.querySelectorAll('.speed-btn');
        const timelineSlider = document.getElementById('timeline-slider');
        const dragHint = document.getElementById('drag-hint');

        const welcomeModalOverlay = document.getElementById('welcome-modal-overlay');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // NEW: Atom Legend Elements
        const atomLegendHeader = document.getElementById('atom-legend-header');
        const atomLegendContent = document.getElementById('atom-legend-content');
        const atomLegendToggle = atomLegendHeader.querySelector('.atom-legend-toggle');

        // NEW: Define atom colors (must match what's in the AI prompt)
        const ATOM_COLORS = [
            { symbol: 'H', color: '#FFFFFF' }, // Trắng
            { symbol: 'O', color: '#FF6B6B' }, // Đỏ
            { symbol: 'C', color: '#333333' }, // Xám đen
            { symbol: 'N', color: '#6B9AFF' }, // Xanh dương
            { symbol: 'Fe', color: '#A19D94' },// Xám kim loại
            { symbol: 'S', color: '#FFF36B' }, // Vàng
            { symbol: 'Cl', color: '#6BFF8B' },// Xanh lá
            { symbol: 'Na', color: '#B06BFF' },// Tím
            { symbol: 'K', color: '#8A2BE2' }, // Tím nhạt
            { symbol: 'Mg', color: '#BDB76B' },// Vàng xanh
            { symbol: 'Ca', color: '#DDA0DD' },// Tím hoa cà
            { symbol: 'Al', color: '#C0C0C0' },// Bạc
            { symbol: 'P', color: '#FFA500' }, // Cam
            { symbol: 'Br', color: '#A52A2A' },// Nâu
            { symbol: 'I', color: '#4B0082' }  // Chàm
        ];


        let currentMessageTimeout;
        function displayMessage(message, isError = false) {
            if (currentMessageTimeout) {
                clearTimeout(currentMessageTimeout);
                currentMessageTimeout = null;
            }

            infoText.textContent = message;
            if (isError) {
                infoText.classList.add('error-message');
            } else {
                infoText.classList.remove('error-message');
            }
            gsap.to(infoText, { opacity: 1, duration: 0.3, ease: "power2.out" });

            if (!isError) {
                currentMessageTimeout = setTimeout(() => {
                    gsap.to(infoText, { opacity: 0, duration: 0.5, ease: "power2.in" });
                }, 5000);
            }
        }

        function toggleDragHint(show) {
            if (dragHint) {
                if (show) {
                    dragHint.classList.add('show');
                } else {
                    dragHint.classList.remove('show');
                }
            }
        }

        function clearScene() {
            molecules.forEach(m => {
                m.children.forEach(c => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                });
                scene.remove(m);
            });
            molecules = [];
        }

        function drawMolecule3D(moleculeDef, x, y, z) {
            const group = new THREE.Group();
            const atomRadius = 0.5;

            moleculeDef.atoms.forEach((atomDef, i) => {
                const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: atomDef.color,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: '#000000'
                });
                const atomMesh = new THREE.Mesh(geometry, material);

                if (moleculeDef.atoms.length > 1) {
                    const angle = (i / moleculeDef.atoms.length) * 2 * Math.PI;
                    atomMesh.position.x = Math.cos(angle) * atomRadius * 1.5;
                    atomMesh.position.y = Math.sin(angle) * atomRadius * 1.5;
                }
                group.add(atomMesh);
            });

            group.position.set(x, y, z);
            scene.add(group);
            molecules.push(group);
            return group;
        }

        // --- Animation Engine ---
        function runAnimation(plan) {
            if (mainTimeline) mainTimeline.kill();
            clearScene();
            
            if (particles) {
                particles.visible = false;
            }
            toggleDragHint(false);

            displayMessage(`Đang chuẩn bị hoạt ảnh cho: ${plan.title}`);

            mainTimeline = gsap.timeline({
                onUpdate: () => {
                    timelineSlider.value = mainTimeline.progress() * 100;
                    playPauseBtn.textContent = mainTimeline.paused() ? "▶️" : "⏸️";
                },
                onComplete: () => {
                    displayMessage("Hoạt ảnh hoàn tất!");
                    playPauseBtn.textContent = "▶️";
                    playPauseBtn.disabled = true;
                    timelineSlider.disabled = true;
                    speedButtons.forEach(btn => btn.disabled = true);
                    if (particles) {
                        particles.visible = true;
                    }
                    toggleDragHint(true);
                }
            });

            playPauseBtn.disabled = false;
            restartBtn.disabled = false;
            timelineSlider.disabled = false;
            speedButtons.forEach(btn => btn.disabled = false);

            playPauseBtn.textContent = "⏸️";

            const reactantObjects = [];
            let reactantX = -10;

            plan.reactants.forEach((r) => {
                for (let j = 0; j < r.count; j++) {
                    const moleculeObj = drawMolecule3D(r, reactantX, (j % 2 === 0 ? 1 : -1) * 4, 0);
                    reactantObjects.push({ obj: moleculeObj });
                    reactantX += 5;
                }
            });

            plan.animationSteps.forEach(step => {
                mainTimeline.add(() => { displayMessage(step.text || '...'); }, step.type);

                if (step.type === 'move_to_center') {
                    mainTimeline.to(camera.position, { z: 25, duration: 2.5, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach((m, i) => {
                        mainTimeline.to(m.obj.position, { x: (i % 3 - 1) * 3, y: Math.floor(i / 3) * 3 - 1, z: 0, duration: 2.5, ease: "power2.inOut" }, step.type);
                    });
                } else if (step.type === 'break_bonds') {
                    mainTimeline.to(camera.position, { z: 12, duration: 2, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach(m => {
                        m.obj.children.forEach((atomMesh, i) => {
                            mainTimeline.to(atomMesh.material.emissive, { r: 1, g: 1, b: 0.8, duration: 1, ease: "power2.in" }, step.type);
                            const angle = (i / m.obj.children.length) * 2 * Math.PI;
                            mainTimeline.to(atomMesh.position, { x: atomMesh.position.x + Math.cos(angle) * 0.8, y: atomMesh.position.y + Math.sin(angle) * 0.8, duration: 2, ease: "back.out(4)" }, step.type);
                        });
                    });
                } else if (step.type === 'rearrange') {
                    reactantObjects.forEach(m => {
                        mainTimeline.to(m.obj.children.map(c => c.material), { opacity: 0, duration: 1, onComplete: () => scene.remove(m.obj) }, step.type);
                    });

                    if (plan.isExothermic) {
                        mainTimeline.add(() => {
                            const shockwaveGeo = new THREE.TorusGeometry(1, 0.1, 16, 100);
                            const shockwaveMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 1 });
                            const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
                            shockwave.rotation.x = Math.PI / 2;
                            scene.add(shockwave);
                            gsap.to(shockwave.scale, { x: 20, y: 20, z: 20, duration: 2, ease: "power1.out" });
                            gsap.to(shockwave.material, { opacity: 0, duration: 2, ease: "power1.out", onComplete: () => scene.remove(shockwave) });
                        }, step.type + "+=0.5");

                    }

                    let productX = -5;
                    plan.products.forEach(p => {
                        for (let j = 0; j < p.count; j++) {
                            const productObj = drawMolecule3D(p, productX, (j % 2 === 0 ? 1 : -1) * 3, 0);
                            productObj.children.forEach(c => { c.material.transparent = true; c.material.opacity = 0; });
                            mainTimeline.to(productObj.children.map(c => c.material), { opacity: 1, duration: 2 }, step.type + "+=1");
                            mainTimeline.to(productObj.children.map(c => c.material.emissive), { r: 0, g: 0, b: 0, duration: 2 }, step.type + "+=1");
                            productX += 5;
                        }
                    });
                }
            });
        }

        async function generateReactionPlan() {
            if (!model || !renderer) {
                displayMessage("Lỗi: Engine AI hoặc môi trường 3D chưa sẵn sàng.", true);
                return;
            }
            const userInput = input.value.trim();
            if (!userInput) {
                displayMessage("Vui lòng nhập các chất tham gia để tạo phản ứng.", true);
                input.classList.add('input-error');
                return;
            } else {
                input.classList.remove('input-error');
            }

            displayMessage('AI đang tư duy... 🧠');
            generateBtn.disabled = true;
            loadingSpinner.classList.remove('hidden');
            playPauseBtn.disabled = true;
            restartBtn.disabled = true;
            timelineSlider.disabled = true;
            speedButtons.forEach(btn => btn.disabled = true);

            if (particles) {
                particles.visible = false;
            }
            toggleDragHint(false);

            const prompt = `
            Từ các chất tham gia do người dùng cung cấp là: "${userInput}".
            Hãy thực hiện các bước sau một cách tuần tự:
            1. Dự đoán sản phẩm hóa học có khả năng xảy ra nhất trong điều kiện tiêu chuẩn.
            2. Viết phương trình hóa học đầy đủ và đã được cân bằng cho phản ứng đó.
            3. Dựa trên phương trình bạn vừa tạo, hãy tạo một kịch bản hoạt ảnh chi tiết dưới dạng một đối tượng JSON.

            Đối tượng JSON phải có cấu trúc chính xác như sau:
            - "title": (string) Phương trình hóa học đầy đủ mà bạn đã tạo (ví dụ: "2H2 + O2 -> 2H2O").
            - "isExothermic": (boolean) Phản ứng có tỏa nhiệt hay không (true nếu tỏa nhiệt, false nếu thu nhiệt hoặc không xác định).
            - "reactants": (array) Một mảng các đối tượng chất phản ứng, mỗi đối tượng có dạng {molecule: string, count: number, atoms: [{symbol: string, color: string}]}.
            - "products": (array) Một mảng các đối tượng sản phẩm, cấu trúc tương tự reactants.
            - "animationSteps": (array) Một mảng các bước hoạt ảnh, mỗi bước có dạng {type: 'move_to_center' | 'break_bonds' | 'rearrange', text: string}.
                - 'move_to_center': Các phân tử di chuyển vào trung tâm buồng phản ứng.
                - 'break_bonds': Liên kết giữa các nguyên tử bị phá vỡ, các nguyên tử tách rời.
                - 'rearrange': Các nguyên tử tự sắp xếp lại để tạo thành sản phẩm mới.

            Sử dụng các màu sau cho nguyên tử (hãy tự suy ra các màu khác nếu cần):
            - H: #FFFFFF (Trắng)
            - O: #FF6B6B (Đỏ)
            - C: #333333 (Xám đen)
            - N: #6B9AFF (Xanh dương)
            - Fe: #A19D94 (Xám kim loại)
            - S: #FFF36B (Vàng)
            - Cl: #6BFF8B (Xanh lá)
            - Na: #B06BFF (Tím)
            - K: #8A2BE2 (Tím nhạt)
            - Mg: #BDB76B (Vàng xanh)
            - Ca: #DDA0DD (Tím hoa cà)
            - Al: #C0C0C0 (Bạc)
            - P: #FFA500 (Cam)
            - Br: #A52A2A (Nâu)
            - I: #4B0082 (Chàm)

            Quan trọng: Chỉ trả lời bằng một khối mã JSON hợp lệ duy nhất, không chứa "'''json" hay bất kỳ văn bản giải thích nào khác.
            `;

            try {
                const result = await model.generateContent(prompt);
                const textResponse = result.response.text();
                const cleanedText = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
                const plan = JSON.parse(cleanedText);

                runAnimation(plan);
            } catch (error) {
                console.error("Error parsing or generating animation:", error);
                displayMessage("Đã có lỗi xảy ra. AI có thể đã trả về định dạng không đúng hoặc gặp lỗi. Vui lòng thử lại.", true);
                if (particles) {
                    particles.visible = true;
                }
                toggleDragHint(true);
            } finally {
                generateBtn.disabled = false;
                loadingSpinner.classList.add('hidden');
            }
        }

        playPauseBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.paused(!mainTimeline.paused());
            }
        });

        restartBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.restart();
            }
        });

        speedButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const speed = parseFloat(event.target.dataset.speed);
                if (mainTimeline) {
                    mainTimeline.timeScale(speed);
                }
                speedButtons.forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            });
        });

        timelineSlider.addEventListener('input', () => {
            if (mainTimeline) {
                mainTimeline.progress(timelineSlider.value / 100);
            }
        });

        // Logic to show/hide welcome modal
        function showWelcomeModal() {
            const hasVisited = localStorage.getItem('hasVisitedChemicalAIApp');
            if (!hasVisited) {
                welcomeModalOverlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            } else {
                initApp();
            }
        }

        function hideWelcomeModal() {
            welcomeModalOverlay.classList.remove('show');
            localStorage.setItem('hasVisitedChemicalAIApp', 'true');
            document.body.style.overflow = '';
            initApp();
        }

        function initApp() {
            init3D();
            generateBtn.addEventListener('click', generateReactionPlan);
            displayMessage("Hãy xem AI dự đoán và diễn họa phản ứng hóa học!");
            toggleDragHint(true);
            populateAtomLegend(); // NEW: Populate the legend on app initialization
        }

        modalCloseBtn.addEventListener('click', hideWelcomeModal);

        showWelcomeModal();

        // NEW: Atom Legend Functions
        function populateAtomLegend() {
            atomLegendContent.innerHTML = ''; // Clear existing content
            ATOM_COLORS.forEach(atom => {
                const item = document.createElement('div');
                item.classList.add('atom-legend-item');
                item.innerHTML = `
                    <div class="atom-color-circle" style="background-color: ${atom.color};"></div>
                    <span>${atom.symbol}</span>
                `;
                atomLegendContent.appendChild(item);
            });
        }

        // NEW: Toggle Atom Legend visibility
        atomLegendHeader.addEventListener('click', () => {
            atomLegendContent.classList.toggle('expanded');
            atomLegendToggle.style.transform = atomLegendContent.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
        });

        // Initial state: collapse the legend by default
        atomLegendContent.classList.remove('expanded');
        atomLegendToggle.style.transform = 'rotate(0deg)';
    </script>
</body>
</html>

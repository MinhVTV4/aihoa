<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine H√≥a h·ªçc AI v3.0 - Nh√† H√≥a h·ªçc AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Variables CSS for easy color management */
        :root {
            --dark-bg: #111827;
            --light-bg: #1f2937;
            --panel-bg: #374151;
            --accent-color: #8b5cf6; /* Accent purple color */
            --danger-color: #ef4444; /* Red color for errors */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e5e7eb; /* Light text color */
            padding: 1rem; /* Overall padding */
        }
        .simulation-container {
            width: 95vw;
            max-width: 1000px;
            background: var(--light-bg);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column; /* Arrange elements vertically */
            gap: 1rem; /* Space between elements */
        }
        /* Add text shadow effect to the title */
        h1 {
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
            transition: text-shadow 0.3s ease-in-out;
        }
        h1:hover {
            text-shadow: 0 0 25px rgba(139, 92, 246, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #reaction-chamber {
            position: relative;
            width: 100%;
            height: 500px; /* Fixed height for the reaction chamber */
            background: var(--dark-bg);
            border-radius: 1rem;
            overflow: hidden; /* Ensure content doesn't overflow */
            cursor: grab; /* Grab cursor */
            display: flex; /* Use flexbox to center WebGL error content */
            justify-content: center;
            align-items: center;
        }
        #reaction-chamber canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* New: Style for the drag hint */
        #drag-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.1rem;
            font-weight: 500;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease-in-out;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10; /* Ensure it's above canvas */
        }
        #drag-hint.show {
            opacity: 1;
        }

        .ui-panel {
            background: var(--panel-bg);
            border-radius: 1rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        /* Update style for textarea */
        #equation-input {
            flex-grow: 1; /* Allow textarea to expand */
            background: var(--light-bg);
            border: 1px solid var(--accent-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #fff;
            outline: none; /* Remove default outline */
            transition: border-color 0.3s; /* Border color transition */
            resize: vertical; /* Allow vertical resizing */
            min-height: 80px; /* Minimum height */
        }
        #equation-input:focus {
            border-color: #a78bfa; /* Border color on focus */
        }
        /* New class for error state */
        #equation-input.input-error {
            border-color: var(--danger-color);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.5); /* Red shadow for error */
        }

        .main-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease; /* Smooth transition effect */
            font-weight: 600;
            display: flex; /* Use flexbox to center spinner and text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .main-btn:hover {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            transform: translateY(-2px); /* Slight lift effect */
        }
        .main-btn:disabled {
            background-image: none;
            background-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #controls-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            justify-content: center; /* Center align buttons */
        }
        .icon-btn {
            background: transparent;
            border: 1px solid #6b7280;
            color: #d1d5db;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2rem;
        }
        .icon-btn:hover {
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }
        .icon-btn:disabled {
            color: #6b7280;
            border-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Add style for speed and timeline sliders */
        .speed-control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem; /* Space below progress bar */
        }
        .speed-btn {
            background-color: var(--panel-bg);
            color: #e5e7eb;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            border: 1px solid #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        .speed-btn:hover:not(.active) {
            border-color: var(--accent-color);
            color: white;
        }
        .speed-btn.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }
        .speed-btn:disabled {
            background-color: #4b5563;
            border-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }

        #timeline-slider {
            width: 100%;
            -webkit-appearance: none; /* Hide default appearance */
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            margin-top: 1rem; /* Space from control buttons */
        }
        #timeline-slider:hover {
            opacity: 1;
        }
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }


        #progress-container {
            flex-grow: 1;
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            overflow: hidden;
            display: none; /* Hide old progress bar, replaced by new slider */
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 99px;
            transition: width 0.3s ease; /* Transition effect for progress bar */
        }
        /* Update style for info-text to act like a toast */
        #info-text {
            text-align: center;
            min-height: 24px; /* Maintain space to prevent layout shift */
            color: #e5e7eb;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease-in-out, color 0.3s ease-in-out; /* Transition effect */
            font-size: 1rem; /* Increase font size */
            font-weight: 600; /* Increase font weight */
        }
        #info-text.error-message {
            color: var(--danger-color); /* Red color for errors */
        }

        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* WebGL Error message */
        .webgl-error-message {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--danger-color); /* Red background for errors */
            color: white;
            border-radius: 0.75rem;
            font-size: 1rem;
            max-width: 80%;
        }
        .webgl-error-message h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .webgl-error-message p {
            margin-bottom: 0.5rem;
        }
        .webgl-error-message a {
            color: #fee2e2;
            text-decoration: underline;
        }
        .webgl-error-message a:hover {
            color: #fff;
        }

        /* New: CSS for Welcome Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .welcome-modal {
            background-color: var(--panel-bg);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.show .welcome-modal {
            transform: scale(1);
        }
        .welcome-modal h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }
        .welcome-modal p {
            font-size: 1rem;
            line-height: 1.5;
            color: #d1d5db;
            margin-bottom: 1.5rem;
        }
        .modal-close-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        .modal-close-btn:hover {
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.6);
            transform: translateY(-3px);
        }

        /* NEW: Styles for Atom Legend */
        .atom-legend {
            background-color: var(--light-bg);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            margin-top: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .atom-legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
            font-weight: 600;
            color: var(--accent-color);
        }
        .atom-legend-header:hover {
            color: #a78bfa;
        }
        .atom-legend-toggle {
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 0.2s ease-in-out;
        }
        .atom-legend-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            display: grid; /* Use grid for layout */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Responsive columns */
            gap: 0.5rem;
            padding-top: 0; /* Initially no padding */
        }
        .atom-legend-content.expanded {
            max-height: 200px; /* Max height when expanded (adjust as needed) */
            overflow-y: auto; /* Enable scrolling if content overflows */
            padding-top: 0.75rem; /* Add padding when expanded */
        }
        .atom-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
        }
        .atom-color-circle {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0; /* Prevent circle from shrinking */
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <h1 class="text-2xl font-bold text-center mb-4">Nh√† H√≥a h·ªçc AI v3.0</h1>
        <div id="reaction-chamber">
            <!-- WebGL error message will be inserted here if needed -->
            <!-- New: Drag hint for 3D interaction -->
            <div id="drag-hint">K√©o ƒë·ªÉ xoay</div>
        </div>
        <div class="ui-panel">
            <div class="input-group">
                <textarea id="equation-input" rows="3" placeholder="Nh·∫≠p c√°c ch·∫•t tham gia (vd: H2 + O2), ho·∫∑c ph∆∞∆°ng tr√¨nh (vd: 2H2 + O2 -> 2H2O), ho·∫∑c m√¥ t·∫£ (vd: Ph·∫£n ·ª©ng ƒë·ªët ch√°y Metan)..."></textarea>
                <button id="generate-btn" class="main-btn">
                    T·∫°o Ph·∫£n ·ª©ng
                    <div id="loading-spinner" class="spinner hidden"></div>
                </button>
            </div>
             <div id="controls-bar">
                <button id="play-pause-btn" class="icon-btn" disabled>‚ñ∂Ô∏è</button>
                <button id="restart-btn" class="icon-btn" disabled>üîÑ</button>
                
                <div class="speed-control-group">
                    <button class="speed-btn" data-speed="0.5" disabled>0.5x</button>
                    <button class="speed-btn active" data-speed="1" disabled>1x</button>
                    <button class="speed-btn" data-speed="2" disabled>2x</button>
                </div>

                <div id="progress-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <input type="range" id="timeline-slider" min="0" max="100" value="0" disabled>

            <!-- NEW: Atom Color Legend Section -->
            <div id="atom-legend" class="atom-legend">
                <div class="atom-legend-header" id="atom-legend-header">
                    <span>Ch√∫ th√≠ch m√†u nguy√™n t·ª≠</span>
                    <span class="atom-legend-toggle">‚ñº</span>
                </div>
                <div class="atom-legend-content" id="atom-legend-content">
                    <!-- Atom items will be dynamically inserted here -->
                </div>
            </div>

            <p id="info-text">H√£y xem AI d·ª± ƒëo√°n v√† di·ªÖn h·ªça ph·∫£n ·ª©ng h√≥a h·ªçc!</p>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div id="welcome-modal-overlay" class="modal-overlay">
        <div class="welcome-modal">
            <h2>Ch√†o m·ª´ng ƒë·∫øn v·ªõi Nh√† H√≥a h·ªçc AI v3.0!</h2>
            <p>Kh√°m ph√° th·∫ø gi·ªõi h√≥a h·ªçc s·ªëng ƒë·ªông v·ªõi s·ª©c m·∫°nh c·ªßa AI.</p>
            <p>Nh·∫≠p c√°c ch·∫•t tham gia ho·∫∑c m·ªôt ph∆∞∆°ng tr√¨nh h√≥a h·ªçc v√†o √¥ b√™n d∆∞·ªõi, sau ƒë√≥ nh·∫•n "T·∫°o Ph·∫£n ·ª©ng" ƒë·ªÉ xem AI di·ªÖn h·ªça qu√° tr√¨nh!</p>
            <p>B·∫°n c≈©ng c√≥ th·ªÉ k√©o ƒë·ªÉ xoay bu·ªìng ph·∫£n ·ª©ng 3D v√† s·ª≠ d·ª•ng c√°c ƒëi·ªÅu khi·ªÉn b√™n d∆∞·ªõi ƒë·ªÉ t√πy ch·ªânh ho·∫°t ·∫£nh.</p>
            <button id="modal-close-btn" class="modal-close-btn">B·∫Øt ƒë·∫ßu ngay!</button>
        </div>
    </div>

    <!-- Imports -->
    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/" } }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Firebase, AI, 3D Engine Setup ---
        const firebaseConfig = { apiKey: "AIzaSyBVpguEIjTnIVOk1Ld0u-BGC7nM-pSww_o", authDomain: "aihoa-ac63b.firebaseapp.com", projectId: "aihoa-ac63b", storageBucket: "aihoa-ac63b.firebasestorage.app", messagingSenderId: "241068548961", appId: "1:241068548961:web:33d4126d020e9372d15b20"};
        let model;
        try {
            const app = initializeApp(firebaseConfig);
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            // Use gemini-2.5-flash for content generation
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        } catch (e) {
            console.error("Firebase/AI initialization error:", e);
            // Display error if AI cannot be initialized
            displayMessage("L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi AI Engine. Vui l√≤ng ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.", true);
            document.getElementById('generate-btn').disabled = true;
        }

        const chamber = document.getElementById('reaction-chamber');
        let renderer, scene, camera, controls, composer, mainTimeline;
        let molecules = [];
        let particles;

        function init3D() {
            chamber.innerHTML = ''; // Clear old WebGL error content if any
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, chamber.clientWidth / chamber.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                chamber.appendChild(renderer.domElement);

                // Setup Post-processing (Bloom effect)
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                const outputPass = new OutputPass();

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
                composer.addPass(outputPass);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                camera.position.z = 15;

                // OrbitControls for camera interaction
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Add particle system
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const particleColor = new THREE.Color(0xffffff); // White color
                const sphereRadius = 20; // Radius of the particle distribution area

                for (let i = 0; i < particleCount; i++) {
                    // Generate random positions within a sphere
                    const x = (Math.random() - 0.5) * 2 * sphereRadius;
                    const y = (Math.random() - 0.5) * 2 * sphereRadius;
                    const z = (Math.random() - 0.5) * 2 * sphereRadius;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // Assign white color with slight opacity
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                }

                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1, // Particle size
                    vertexColors: true, // Use colors from attribute
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending // Additive blending for brighter particles
                });

                particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                particles.visible = true; // Show particles by default

                // Main animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    // Rotate particles gently
                    if (particles && particles.visible) {
                        particles.rotation.y += 0.0005;
                        particles.rotation.x += 0.0002;
                    }
                    composer.render();
                }
                animate();

                // Listen for window resize events
                window.addEventListener('resize', () => {
                    camera.aspect = chamber.clientWidth / chamber.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                    composer.setSize(chamber.clientWidth, chamber.clientHeight);
                });

            } catch (error) {
                console.error("WebGL initialization error:", error);
                // Display more user-friendly error message
                chamber.innerHTML = `
                    <div class="webgl-error-message">
                        <h2>L·ªói WebGL</h2>
                        <p>Tr√¨nh duy·ªát c·ªßa b·∫°n c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ ho·∫∑c WebGL ƒëang b·ªã t·∫Øt.</p>
                        <p>ƒê·ªÉ tr·∫£i nghi·ªám ho·∫°t ·∫£nh 3D, vui l√≤ng ƒë·∫£m b·∫£o tr√¨nh duy·ªát c·ªßa b·∫°n ƒë∆∞·ª£c c·∫≠p nh·∫≠t v√† WebGL ƒë∆∞·ª£c b·∫≠t.</p>
                        <p><a href="https://get.webgl.org/" target="_blank">Ki·ªÉm tra tr·∫°ng th√°i WebGL c·ªßa b·∫°n t·∫°i ƒë√¢y</a></p>
                    </div>
                `;
                generateBtn.disabled = true;
                throw new Error("WebGL init failed");
            }
        }

        // --- Core Application Logic ---
        const generateBtn = document.getElementById('generate-btn');
        const input = document.getElementById('equation-input');
        const infoText = document.getElementById('info-text');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const speedButtons = document.querySelectorAll('.speed-btn');
        const timelineSlider = document.getElementById('timeline-slider');
        const dragHint = document.getElementById('drag-hint');

        const welcomeModalOverlay = document.getElementById('welcome-modal-overlay');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // NEW: Atom Legend Elements
        const atomLegendHeader = document.getElementById('atom-legend-header');
        const atomLegendContent = document.getElementById('atom-legend-content');
        const atomLegendToggle = atomLegendHeader.querySelector('.atom-legend-toggle');

        // NEW: Define atom colors (must match what's in the AI prompt)
        const ATOM_COLORS = [
            { symbol: 'H', color: '#FFFFFF' }, // Tr·∫Øng
            { symbol: 'O', color: '#FF6B6B' }, // ƒê·ªè
            { symbol: 'C', color: '#333333' }, // X√°m ƒëen
            { symbol: 'N', color: '#6B9AFF' }, // Xanh d∆∞∆°ng
            { symbol: 'Fe', color: '#A19D94' },// X√°m kim lo·∫°i
            { symbol: 'S', color: '#FFF36B' }, // V√†ng
            { symbol: 'Cl', color: '#6BFF8B' },// Xanh l√°
            { symbol: 'Na', color: '#B06BFF' },// T√≠m
            { symbol: 'K', color: '#8A2BE2' }, // T√≠m nh·∫°t
            { symbol: 'Mg', color: '#BDB76B' },// V√†ng xanh
            { symbol: 'Ca', color: '#DDA0DD' },// T√≠m hoa c√†
            { symbol: 'Al', color: '#C0C0C0' },// B·∫°c
            { symbol: 'P', color: '#FFA500' }, // Cam
            { symbol: 'Br', color: '#A52A2A' },// N√¢u
            { symbol: 'I', color: '#4B0082' }  // Ch√†m
        ];


        let currentMessageTimeout;
        function displayMessage(message, isError = false) {
            if (currentMessageTimeout) {
                clearTimeout(currentMessageTimeout);
                currentMessageTimeout = null;
            }

            infoText.textContent = message;
            if (isError) {
                infoText.classList.add('error-message');
            } else {
                infoText.classList.remove('error-message');
            }
            gsap.to(infoText, { opacity: 1, duration: 0.3, ease: "power2.out" });

            if (!isError) {
                currentMessageTimeout = setTimeout(() => {
                    gsap.to(infoText, { opacity: 0, duration: 0.5, ease: "power2.in" });
                }, 5000);
            }
        }

        function toggleDragHint(show) {
            if (dragHint) {
                if (show) {
                    dragHint.classList.add('show');
                } else {
                    dragHint.classList.remove('show');
                }
            }
        }

        function clearScene() {
            molecules.forEach(m => {
                m.children.forEach(c => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                });
                scene.remove(m);
            });
            molecules = [];
        }

        function drawMolecule3D(moleculeDef, x, y, z) {
            const group = new THREE.Group();
            const atomRadius = 0.5;

            moleculeDef.atoms.forEach((atomDef, i) => {
                const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: atomDef.color,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: '#000000'
                });
                const atomMesh = new THREE.Mesh(geometry, material);

                if (moleculeDef.atoms.length > 1) {
                    const angle = (i / moleculeDef.atoms.length) * 2 * Math.PI;
                    atomMesh.position.x = Math.cos(angle) * atomRadius * 1.5;
                    atomMesh.position.y = Math.sin(angle) * atomRadius * 1.5;
                }
                group.add(atomMesh);
            });

            group.position.set(x, y, z);
            scene.add(group);
            molecules.push(group);
            return group;
        }

        // --- Animation Engine ---
        function runAnimation(plan) {
            if (mainTimeline) mainTimeline.kill();
            clearScene();
            
            if (particles) {
                particles.visible = false;
            }
            toggleDragHint(false);

            displayMessage(`ƒêang chu·∫©n b·ªã ho·∫°t ·∫£nh cho: ${plan.title}`);

            mainTimeline = gsap.timeline({
                onUpdate: () => {
                    timelineSlider.value = mainTimeline.progress() * 100;
                    playPauseBtn.textContent = mainTimeline.paused() ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
                },
                onComplete: () => {
                    displayMessage("Ho·∫°t ·∫£nh ho√†n t·∫•t!");
                    playPauseBtn.textContent = "‚ñ∂Ô∏è";
                    playPauseBtn.disabled = true;
                    timelineSlider.disabled = true;
                    speedButtons.forEach(btn => btn.disabled = true);
                    if (particles) {
                        particles.visible = true;
                    }
                    toggleDragHint(true);
                }
            });

            playPauseBtn.disabled = false;
            restartBtn.disabled = false;
            timelineSlider.disabled = false;
            speedButtons.forEach(btn => btn.disabled = false);

            playPauseBtn.textContent = "‚è∏Ô∏è";

            const reactantObjects = [];
            let reactantX = -10;

            plan.reactants.forEach((r) => {
                for (let j = 0; j < r.count; j++) {
                    const moleculeObj = drawMolecule3D(r, reactantX, (j % 2 === 0 ? 1 : -1) * 4, 0);
                    reactantObjects.push({ obj: moleculeObj });
                    reactantX += 5;
                }
            });

            plan.animationSteps.forEach(step => {
                mainTimeline.add(() => { displayMessage(step.text || '...'); }, step.type);

                if (step.type === 'move_to_center') {
                    mainTimeline.to(camera.position, { z: 25, duration: 2.5, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach((m, i) => {
                        mainTimeline.to(m.obj.position, { x: (i % 3 - 1) * 3, y: Math.floor(i / 3) * 3 - 1, z: 0, duration: 2.5, ease: "power2.inOut" }, step.type);
                    });
                } else if (step.type === 'break_bonds') {
                    mainTimeline.to(camera.position, { z: 12, duration: 2, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach(m => {
                        m.obj.children.forEach((atomMesh, i) => {
                            mainTimeline.to(atomMesh.material.emissive, { r: 1, g: 1, b: 0.8, duration: 1, ease: "power2.in" }, step.type);
                            const angle = (i / m.obj.children.length) * 2 * Math.PI;
                            mainTimeline.to(atomMesh.position, { x: atomMesh.position.x + Math.cos(angle) * 0.8, y: atomMesh.position.y + Math.sin(angle) * 0.8, duration: 2, ease: "back.out(4)" }, step.type);
                        });
                    });
                } else if (step.type === 'rearrange') {
                    reactantObjects.forEach(m => {
                        mainTimeline.to(m.obj.children.map(c => c.material), { opacity: 0, duration: 1, onComplete: () => scene.remove(m.obj) }, step.type);
                    });

                    if (plan.isExothermic) {
                        mainTimeline.add(() => {
                            const shockwaveGeo = new THREE.TorusGeometry(1, 0.1, 16, 100);
                            const shockwaveMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 1 });
                            const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
                            shockwave.rotation.x = Math.PI / 2;
                            scene.add(shockwave);
                            gsap.to(shockwave.scale, { x: 20, y: 20, z: 20, duration: 2, ease: "power1.out" });
                            gsap.to(shockwave.material, { opacity: 0, duration: 2, ease: "power1.out", onComplete: () => scene.remove(shockwave) });
                        }, step.type + "+=0.5");

                    }

                    let productX = -5;
                    plan.products.forEach(p => {
                        for (let j = 0; j < p.count; j++) {
                            const productObj = drawMolecule3D(p, productX, (j % 2 === 0 ? 1 : -1) * 3, 0);
                            productObj.children.forEach(c => { c.material.transparent = true; c.material.opacity = 0; });
                            mainTimeline.to(productObj.children.map(c => c.material), { opacity: 1, duration: 2 }, step.type + "+=1");
                            mainTimeline.to(productObj.children.map(c => c.material.emissive), { r: 0, g: 0, b: 0, duration: 2 }, step.type + "+=1");
                            productX += 5;
                        }
                    });
                }
            });
        }

        async function generateReactionPlan() {
            if (!model || !renderer) {
                displayMessage("L·ªói: Engine AI ho·∫∑c m√¥i tr∆∞·ªùng 3D ch∆∞a s·∫µn s√†ng.", true);
                return;
            }
            const userInput = input.value.trim();
            if (!userInput) {
                displayMessage("Vui l√≤ng nh·∫≠p c√°c ch·∫•t tham gia ƒë·ªÉ t·∫°o ph·∫£n ·ª©ng.", true);
                input.classList.add('input-error');
                return;
            } else {
                input.classList.remove('input-error');
            }

            displayMessage('AI ƒëang t∆∞ duy... üß†');
            generateBtn.disabled = true;
            loadingSpinner.classList.remove('hidden');
            playPauseBtn.disabled = true;
            restartBtn.disabled = true;
            timelineSlider.disabled = true;
            speedButtons.forEach(btn => btn.disabled = true);

            if (particles) {
                particles.visible = false;
            }
            toggleDragHint(false);

            const prompt = `
            T·ª´ c√°c ch·∫•t tham gia do ng∆∞·ªùi d√πng cung c·∫•p l√†: "${userInput}".
            H√£y th·ª±c hi·ªán c√°c b∆∞·ªõc sau m·ªôt c√°ch tu·∫ßn t·ª±:
            1. D·ª± ƒëo√°n s·∫£n ph·∫©m h√≥a h·ªçc c√≥ kh·∫£ nƒÉng x·∫£y ra nh·∫•t trong ƒëi·ªÅu ki·ªán ti√™u chu·∫©n.
            2. Vi·∫øt ph∆∞∆°ng tr√¨nh h√≥a h·ªçc ƒë·∫ßy ƒë·ªß v√† ƒë√£ ƒë∆∞·ª£c c√¢n b·∫±ng cho ph·∫£n ·ª©ng ƒë√≥.
            3. D·ª±a tr√™n ph∆∞∆°ng tr√¨nh b·∫°n v·ª´a t·∫°o, h√£y t·∫°o m·ªôt k·ªãch b·∫£n ho·∫°t ·∫£nh chi ti·∫øt d∆∞·ªõi d·∫°ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON.

            ƒê·ªëi t∆∞·ª£ng JSON ph·∫£i c√≥ c·∫•u tr√∫c ch√≠nh x√°c nh∆∞ sau:
            - "title": (string) Ph∆∞∆°ng tr√¨nh h√≥a h·ªçc ƒë·∫ßy ƒë·ªß m√† b·∫°n ƒë√£ t·∫°o (v√≠ d·ª•: "2H2 + O2 -> 2H2O").
            - "isExothermic": (boolean) Ph·∫£n ·ª©ng c√≥ t·ªèa nhi·ªát hay kh√¥ng (true n·∫øu t·ªèa nhi·ªát, false n·∫øu thu nhi·ªát ho·∫∑c kh√¥ng x√°c ƒë·ªãnh).
            - "reactants": (array) M·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng ch·∫•t ph·∫£n ·ª©ng, m·ªói ƒë·ªëi t∆∞·ª£ng c√≥ d·∫°ng {molecule: string, count: number, atoms: [{symbol: string, color: string}]}.
            - "products": (array) M·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng s·∫£n ph·∫©m, c·∫•u tr√∫c t∆∞∆°ng t·ª± reactants.
            - "animationSteps": (array) M·ªôt m·∫£ng c√°c b∆∞·ªõc ho·∫°t ·∫£nh, m·ªói b∆∞·ªõc c√≥ d·∫°ng {type: 'move_to_center' | 'break_bonds' | 'rearrange', text: string}.
                - 'move_to_center': C√°c ph√¢n t·ª≠ di chuy·ªÉn v√†o trung t√¢m bu·ªìng ph·∫£n ·ª©ng.
                - 'break_bonds': Li√™n k·∫øt gi·ªØa c√°c nguy√™n t·ª≠ b·ªã ph√° v·ª°, c√°c nguy√™n t·ª≠ t√°ch r·ªùi.
                - 'rearrange': C√°c nguy√™n t·ª≠ t·ª± s·∫Øp x·∫øp l·∫°i ƒë·ªÉ t·∫°o th√†nh s·∫£n ph·∫©m m·ªõi.

            S·ª≠ d·ª•ng c√°c m√†u sau cho nguy√™n t·ª≠ (h√£y t·ª± suy ra c√°c m√†u kh√°c n·∫øu c·∫ßn):
            - H: #FFFFFF (Tr·∫Øng)
            - O: #FF6B6B (ƒê·ªè)
            - C: #333333 (X√°m ƒëen)
            - N: #6B9AFF (Xanh d∆∞∆°ng)
            - Fe: #A19D94 (X√°m kim lo·∫°i)
            - S: #FFF36B (V√†ng)
            - Cl: #6BFF8B (Xanh l√°)
            - Na: #B06BFF (T√≠m)
            - K: #8A2BE2 (T√≠m nh·∫°t)
            - Mg: #BDB76B (V√†ng xanh)
            - Ca: #DDA0DD (T√≠m hoa c√†)
            - Al: #C0C0C0 (B·∫°c)
            - P: #FFA500 (Cam)
            - Br: #A52A2A (N√¢u)
            - I: #4B0082 (Ch√†m)

            Quan tr·ªçng: Ch·ªâ tr·∫£ l·ªùi b·∫±ng m·ªôt kh·ªëi m√£ JSON h·ª£p l·ªá duy nh·∫•t, kh√¥ng ch·ª©a "'''json" hay b·∫•t k·ª≥ vƒÉn b·∫£n gi·∫£i th√≠ch n√†o kh√°c.
            `;

            try {
                const result = await model.generateContent(prompt);
                const textResponse = result.response.text();
                const cleanedText = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
                const plan = JSON.parse(cleanedText);

                runAnimation(plan);
            } catch (error) {
                console.error("Error parsing or generating animation:", error);
                displayMessage("ƒê√£ c√≥ l·ªói x·∫£y ra. AI c√≥ th·ªÉ ƒë√£ tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng ho·∫∑c g·∫∑p l·ªói. Vui l√≤ng th·ª≠ l·∫°i.", true);
                if (particles) {
                    particles.visible = true;
                }
                toggleDragHint(true);
            } finally {
                generateBtn.disabled = false;
                loadingSpinner.classList.add('hidden');
            }
        }

        playPauseBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.paused(!mainTimeline.paused());
            }
        });

        restartBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.restart();
            }
        });

        speedButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const speed = parseFloat(event.target.dataset.speed);
                if (mainTimeline) {
                    mainTimeline.timeScale(speed);
                }
                speedButtons.forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            });
        });

        timelineSlider.addEventListener('input', () => {
            if (mainTimeline) {
                mainTimeline.progress(timelineSlider.value / 100);
            }
        });

        // Logic to show/hide welcome modal
        function showWelcomeModal() {
            const hasVisited = localStorage.getItem('hasVisitedChemicalAIApp');
            if (!hasVisited) {
                welcomeModalOverlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            } else {
                initApp();
            }
        }

        function hideWelcomeModal() {
            welcomeModalOverlay.classList.remove('show');
            localStorage.setItem('hasVisitedChemicalAIApp', 'true');
            document.body.style.overflow = '';
            initApp();
        }

        function initApp() {
            init3D();
            generateBtn.addEventListener('click', generateReactionPlan);
            displayMessage("H√£y xem AI d·ª± ƒëo√°n v√† di·ªÖn h·ªça ph·∫£n ·ª©ng h√≥a h·ªçc!");
            toggleDragHint(true);
            populateAtomLegend(); // NEW: Populate the legend on app initialization
        }

        modalCloseBtn.addEventListener('click', hideWelcomeModal);

        showWelcomeModal();

        // NEW: Atom Legend Functions
        function populateAtomLegend() {
            atomLegendContent.innerHTML = ''; // Clear existing content
            ATOM_COLORS.forEach(atom => {
                const item = document.createElement('div');
                item.classList.add('atom-legend-item');
                item.innerHTML = `
                    <div class="atom-color-circle" style="background-color: ${atom.color};"></div>
                    <span>${atom.symbol}</span>
                `;
                atomLegendContent.appendChild(item);
            });
        }

        // NEW: Toggle Atom Legend visibility
        atomLegendHeader.addEventListener('click', () => {
            atomLegendContent.classList.toggle('expanded');
            atomLegendToggle.style.transform = atomLegendContent.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
        });

        // Initial state: collapse the legend by default
        atomLegendContent.classList.remove('expanded');
        atomLegendToggle.style.transform = 'rotate(0deg)';
    </script>
</body>
</html>

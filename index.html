<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Hóa - Mô phỏng Phản ứng Hóa học</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Google Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }
        #header {
            background-color: #2a2a3e;
            padding: 1rem;
            border-bottom: 1px solid #4a4a6a;
            text-align: center;
            position: relative;
            z-index: 10;
        }
        #header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: 0.05em;
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
        }
        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        #reaction-chamber {
            flex-grow: 1;
            background-color: #1a1a2e;
            position: relative;
            overflow: hidden; /* Ensure 3D content stays within bounds */
        }
        #reaction-chamber canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls {
            background-color: #2a2a3e;
            padding: 1rem;
            border-top: 1px solid #4a4a6a;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: relative;
            z-index: 10;
        }
        .input-group, .control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #equation-input {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid #4a4a6a;
            background-color: #3a3a5a;
            color: #e0e0e0;
            font-size: 1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
            min-width: 200px; /* Ensure input is not too small */
        }
        #equation-input:focus {
            border-color: #8a6bfa;
            box-shadow: 0 0 0 2px rgba(138, 107, 250, 0.5);
            outline: none;
        }
        #equation-input.input-error {
            border-color: #ef4444;
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.5);
        }
        #equation-input.input-valid {
            border-color: #22c55e;
        }
        .control-btn, #generate-btn {
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            white-space: nowrap; /* Prevent text wrapping */
        }
        #generate-btn {
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            color: #ffffff;
            box-shadow: 0 4px 10px rgba(106, 130, 251, 0.4);
        }
        #generate-btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(106, 130, 251, 0.6);
        }
        #generate-btn:disabled {
            background: #4a4a6a;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }
        .control-btn {
            background-color: #4a4a6a;
            color: #e0e0e0;
        }
        .control-btn:hover:not(:disabled) {
            background-color: #5a5a7a;
            transform: translateY(-1px);
        }
        .control-btn:disabled {
            background-color: #3a3a5a;
            color: #888;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .speed-btn {
            background-color: #3a3a5a;
            color: #e0e0e0;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }
        .speed-btn:hover:not(:disabled) {
            background-color: #5a5a7a;
        }
        .speed-btn.active {
            background-color: #6a82fb;
            color: #ffffff;
            font-weight: 600;
        }

        #timeline-slider {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 8px;
            background: #4a4a6a;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            cursor: pointer;
        }
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fc5c7d;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(252, 92, 125, 0.8);
        }
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fc5c7d;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(252, 92, 125, 0.8);
        }
        #info-text {
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #b0b0b0;
            opacity: 0;
            transition: opacity 0.3s;
            min-height: 1.5rem;
        }
        #info-text.error-message {
            color: #ef4444;
            font-weight: 600;
        }
        #loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 0.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none !important; }

        /* Welcome Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: #2a2a3e;
            border: 1px solid #4a4a6a;
            padding: 2.5rem;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            text-align: center;
            position: relative;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.7);
        }
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        .modal-content h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .modal-content p {
            font-size: 1.1rem;
            color: #b0b0b0;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        .modal-close-btn {
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            color: #ffffff;
            padding: 0.8rem 2rem;
            border-radius: 8px;
            border: none;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(106, 130, 251, 0.4);
        }
        .modal-close-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(106, 130, 251, 0.6);
        }

        /* Drag Hint */
        #drag-hint {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.6);
            color: #e0e0e0;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 5;
        }
        #drag-hint.show {
            opacity: 1;
        }

        /* Molecule Tooltip */
        #molecule-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 0.5rem 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease-out;
            z-index: 100;
            max-width: 200px;
            line-height: 1.4;
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #molecule-tooltip.show {
            opacity: 1;
        }

        /* Suggestions List */
        #suggestions-list {
            position: absolute;
            top: 100%; /* Below the input */
            left: 0;
            right: 0;
            background-color: #3a3a5a;
            border: 1px solid #4a4a6a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        #suggestions-list.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        .suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: #e0e0e0;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .suggestion-item:hover {
            background-color: #4a4a6a;
        }

        /* WebGL Error Message */
        .webgl-error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 2rem;
            border-radius: 10px;
            color: #ffcccc;
            border: 1px solid #ff6b6b;
            max-width: 90%;
        }
        .webgl-error-message h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #ff6b6b;
        }
        .webgl-error-message p {
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 1rem;
        }
        .webgl-error-message a {
            color: #8a6bfa;
            text-decoration: underline;
        }

        /* Explanation Mode Modal */
        #explanation-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #explanation-modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        #explanation-modal-content {
            background: #2a2a3e;
            border: 1px solid #4a4a6a;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.7);
        }
        #explanation-modal-overlay.show #explanation-modal-content {
            transform: scale(1);
        }
        #explanation-title {
            font-size: 1.75rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #explanation-text {
            font-size: 1rem;
            color: #b0b0b0;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        #explanation-continue-btn {
            background: linear-gradient(90deg, #6a82fb, #fc5c7d);
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #explanation-continue-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Atom Legend */
        #atom-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 0.75rem;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 200px;
        }
        #atom-legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        #atom-legend-header h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e0e0e0;
        }
        .atom-legend-toggle {
            transition: transform 0.3s ease;
        }
        #atom-legend-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            padding-top: 0;
        }
        #atom-legend-content.expanded {
            max-height: 300px; /* Sufficient height for content */
            opacity: 1;
            padding-top: 0.75rem;
        }
        .atom-color-circle {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .atom-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: #c0c0c0;
        }
        .atom-legend-item:last-child {
            margin-bottom: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #header h1 {
                font-size: 1.5rem;
            }
            .input-group, .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            #equation-input {
                width: 100%;
            }
            #generate-btn, .control-btn {
                width: 100%;
            }
            #timeline-slider {
                width: 100%;
            }
            #atom-legend {
                position: static; /* Stack on mobile */
                width: auto;
                max-width: none;
                margin: 0.5rem;
            }
            #controls {
                padding: 0.75rem;
            }
            .speed-buttons {
                justify-content: center;
            }
        }
        @media (max-width: 480px) {
            .modal-content {
                padding: 1.5rem;
            }
            .modal-content h2 {
                font-size: 1.5rem;
            }
            .modal-content p {
                font-size: 0.9rem;
            }
            .modal-close-btn {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header id="header">
            <h1>AI Hóa - Mô phỏng Phản ứng</h1>
        </header>

        <main id="main-content">
            <div id="reaction-chamber">
                <!-- 3D Scene will be rendered here -->
            </div>

            <div id="atom-legend">
                <div id="atom-legend-header">
                    <h3>Chú thích Nguyên tử</h3>
                    <span class="material-icons atom-legend-toggle">expand_less</span>
                </div>
                <div id="atom-legend-content">
                    <!-- Atom legend items will be dynamically inserted here -->
                </div>
            </div>
            
            <div id="drag-hint" class="hidden">
                Kéo để xoay camera. Cuộn để phóng to/thu nhỏ.
            </div>

            <div id="controls">
                <div class="input-group">
                    <input type="text" id="equation-input" placeholder="Nhập chất tham gia (ví dụ: H2 + O2)">
                    <button id="clear-input-btn" class="control-btn hidden" title="Xóa đầu vào">
                        <span class="material-icons">clear</span>
                    </button>
                    <div id="suggestions-list"></div>
                </div>
                <div class="control-group">
                    <button id="generate-btn" class="control-btn">
                        Tạo Hoạt ảnh
                        <span id="loading-spinner" class="hidden"></span>
                    </button>
                    <button id="play-pause-btn" class="control-btn" disabled>
                        <span class="material-icons">play_arrow</span>
                    </button>
                    <button id="restart-btn" class="control-btn" disabled>
                        <span class="material-icons">replay</span>
                    </button>
                    <input type="range" id="timeline-slider" min="0" max="100" value="0" disabled>
                </div>
                <div class="control-group speed-buttons">
                    <button class="control-btn speed-btn" data-speed="0.5" disabled>0.5x</button>
                    <button class="control-btn speed-btn active" data-speed="1.0" disabled>1x</button>
                    <button class="control-btn speed-btn" data-speed="1.5" disabled>1.5x</button>
                    <button class="control-btn speed-btn" data-speed="2.0" disabled>2x</button>
                    <button id="explanation-mode-toggle" class="control-btn" disabled>Chế độ Giải thích</button>
                </div>
                <div id="info-text"></div>
            </div>
        </main>

        <!-- Welcome Modal -->
        <div id="welcome-modal-overlay" class="modal-overlay">
            <div class="modal-content">
                <h2>Chào mừng đến với AI Hóa!</h2>
                <p>Tôi có thể giúp bạn hình dung các phản ứng hóa học thông qua hoạt ảnh 3D đẹp mắt. Chỉ cần nhập chất tham gia, AI của tôi sẽ dự đoán phản ứng, cân bằng phương trình và tạo ra một mô phỏng trực quan. Hãy cùng khám phá khoa học!</p>
                <button id="modal-close-btn" class="modal-close-btn">Bắt đầu</button>
            </div>
        </div>

        <!-- Explanation Modal -->
        <div id="explanation-modal-overlay" class="modal-overlay">
            <div id="explanation-modal-content">
                <h2 id="explanation-title">Bước 1: Chuẩn bị</h2>
                <p id="explanation-text">Các phân tử chất phản ứng đang di chuyển ngẫu nhiên trong buồng phản ứng, sẵn sàng tương tác.</p>
                <button id="explanation-continue-btn" class="modal-close-btn">Tiếp tục</button>
            </div>
        </div>

        <!-- Molecule Tooltip -->
        <div id="molecule-tooltip"></div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GSAP Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/MotionPathPlugin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/EasePack.min.js"></script>
    
    <!-- Three.js Addons for Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/OutputPass.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        // Correct OrbitControls import for ES Module
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Firebase, AI, 3D Engine Setup ---
        // Firebase configuration from aihoa2.html
        const firebaseConfig = { 
            apiKey: "AIzaSyBVpguEIjTnIVOk1Ld0u-BGC7nM-pSww_o", 
            authDomain: "aihoa-ac63b.firebaseapp.com", 
            projectId: "aihoa-ac63b", 
            storageBucket: "aihoa-ac63b.firebasestorage.app", 
            messagingSenderId: "241068548961", 
            appId: "1:241068548961:web:33d4126d020e9372d15b20"
        };
        let model;
        try {
            // Initialize Firebase app
            const app = initializeApp(firebaseConfig);
            // Get AI service with GoogleAIBackend
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            // Use gemini-2.5-flash for content generation
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        } catch (e) {
            console.error("Firebase/AI initialization error:", e);
            // Display error if AI cannot be initialized
            displayMessage("Lỗi: Không thể kết nối với AI Engine. Vui lòng kiểm tra console để biết chi tiết.", true);
            document.getElementById('generate-btn').disabled = true;
        }

        const chamber = document.getElementById('reaction-chamber');
        let renderer, scene, camera, controls, composer, mainTimeline;
        let molecules = []; // Stores THREE.Group objects representing molecules
        let particles;
        let solutionContainer; // Declare solution container globally

        // For molecule tooltip
        const moleculeTooltip = document.getElementById('molecule-tooltip');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredMolecule = null;

        // Data for example reactions
        const exampleReactions = [
            {
                category: "🧪 Phản ứng của axit - bazơ - muối",
                reactions: [
                    { name: "HCl + NaOH → NaCl + H₂O", input: "HCl + NaOH" },
                    { name: "H₂SO₄ + 2NaOH → Na₂SO₄ + 2H₂O", input: "H2SO4 + NaOH" },
                    { name: "HCl + AgNO₃ → AgCl↓ + HNO₃", input: "HCl + AgNO3" },
                    { name: "H₂SO₄ + BaCl₂ → BaSO₄↓ + 2HCl", input: "H2SO4 + BaCl2" },
                    { name: "NaOH + CuSO₄ → Cu(OH)₂↓ + Na₂SO₄", input: "NaOH + CuSO4" },
                    { name: "Ba(OH)₂ + FeCl₃ → Fe(OH)₃↓ + BaCl₂", input: "Ba(OH)2 + FeCl3" },
                ]
            },
            {
                category: "🔥 Phản ứng oxi hóa - khử",
                reactions: [
                    { name: "Zn + 2HCl → ZnCl₂ + H₂↑", input: "Zn + HCl" },
                    { name: "Fe + H₂SO₄ → FeSO₄ + H₂↑", input: "Fe + H2SO4" },
                    { name: "Fe + CuSO₄ → FeSO₄ + Cu↓", input: "Fe + CuSO4" },
                    { name: "Zn + AgNO₃ → Zn(NO₃)₂ + Ag↓", input: "Zn + AgNO3" },
                    { name: "CH₄ + 2O₂ → CO₂ + 2H₂O", input: "CH4 + O2" },
                    { name: "2Mg + O₂ → 2MgO", input: "Mg + O2" },
                ]
            },
            {
                category: "🧱 Phản ứng phân hủy",
                reactions: [
                    { name: "2KClO₃ → 2KCl + 3O₂", input: "KClO3" },
                    { name: "CaCO₃ → CaO + CO₂", input: "CaCO3" },
                ]
            },
            {
                category: "🧊 Phản ứng đặc trưng của phi kim",
                reactions: [
                    { name: "Fe + S → FeS", input: "Fe + S" },
                    { name: "2Al + 3Cl₂ → 2AlCl₃", input: "Al + Cl2" },
                    { name: "H₂ + Cl₂ → 2HCl", input: "H2 + Cl2" },
                    { name: "N₂ + 3H₂ ⇌ 2NH₃", input: "N2 + H2" },
                ]
            },
            {
                category: "🧬 Phản ứng hữu cơ cơ bản",
                reactions: [
                    { name: "CH₂=CH₂ + Br₂ → CH₂Br–CH₂Br", input: "CH2=CH2 + Br2" },
                    { name: "CH≡CH + H₂ → CH₂=CH₂", input: "CH=CH + H2" },
                    { name: "C₂H₆ + O₂ → CO₂ + H₂O", input: "C2H6 + O2" },
                    { name: "CH₃COOH + O₂ → CO₂ + 2H₂O", input: "CH3COOH + O2" },
                ]
            },
            {
                category: "🧫 Phản ứng đặc trưng trong nhóm chất",
                reactions: [
                    { name: "BaCl₂ + Na₂SO₄ → BaSO₄↓ + 2NaCl", input: "BaCl2 + Na2SO4" },
                    { name: "AgNO₃ + NaCl → AgCl↓ + NaNO₃", input: "AgNO3 + NaCl" },
                    { name: "NaHCO₃ + HCl → NaCl + CO₂↑ + H₂O", input: "NaHCO3 + HCl" },
                ]
            }
        ];

        /**
         * Initializes the 3D scene, camera, renderer, lights, controls, and particle system.
         * Handles WebGL error display.
         */
        function init3D() {
            chamber.innerHTML = ''; // Clear old WebGL error content if any
            try {
                // Scene, Camera, Renderer setup
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, chamber.clientWidth / chamber.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                chamber.appendChild(renderer.domElement);

                // Setup Post-processing (Bloom effect) for visual enhancement
                const renderPass = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                const outputPass = new THREE.OutputPass();

                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
                composer.addPass(outputPass);

                // Add lights to the scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
                ambientLight.name = "ambientLight";
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Directional light for shadows/highlights
                directionalLight.name = "directionalLight";
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                camera.position.z = 20; // Initial camera position, slightly further out

                // OrbitControls for interactive camera movement
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; // Smooth camera movement

                // Add particle system for background ambiance
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const particleColor = new THREE.Color(0xffffff); // White particles
                const sphereRadius = 25; // Increased radius
                for (let i = 0; i < particleCount; i++) {
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const x = sphereRadius * Math.sin(phi) * Math.cos(theta);
                    const y = sphereRadius * Math.sin(phi) * Math.sin(theta);
                    const z = sphereRadius * Math.cos(phi);
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                }
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particleGeometry.userData.originalPositions = new Float32Array(positions); // Store original positions
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1, vertexColors: true, transparent: true,
                    opacity: 0.5, blending: THREE.AdditiveBlending
                });
                particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);

                // Create solution container
                const solutionGeometry = new THREE.BoxGeometry(12, 12, 12);
                const solutionMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000, transparent: true, opacity: 0.0
                });
                solutionContainer = new THREE.Mesh(solutionGeometry, solutionMaterial);
                solutionContainer.visible = false;
                scene.add(solutionContainer);

                // Time variable for perpetual motion
                let time = 0;

                function animate() {
                    requestAnimationFrame(animate);
                    time += 0.05; // Increment time for vibration
                    controls.update();

                    // Perpetual motion logic for "living" molecules
                    if (mainTimeline && mainTimeline.progress() === 1) {
                        molecules.forEach(group => {
                            const data = group.userData.moleculeData;
                            if (data && data.drift) { 
                                group.position.add(data.drift);

                                const wrapLimit = 22;
                                if (group.position.x > wrapLimit) group.position.x = -wrapLimit;
                                if (group.position.x < -wrapLimit) group.position.x = wrapLimit;
                                if (group.position.y > 15) group.position.y = -15;
                                if (group.position.y < -15) group.position.y = 15;
                                if (group.position.z > wrapLimit) group.position.z = -wrapLimit;
                                if (group.position.z < -wrapLimit) group.position.z = wrapLimit;

                                group.rotation.x += data.rotationSpeed.x;
                                group.rotation.y += data.rotationSpeed.y;
                                group.rotation.z += data.rotationSpeed.z;

                                data.atoms.forEach((atom, i) => {
                                    const originalPos = data.originalAtomPositions[i];
                                    const vibrationData = data.vibrationParams[i];
                                    const vibration = Math.sin(time * vibrationData.speed + vibrationData.phase) * 0.03;
                                    atom.position.copy(originalPos).addScaledVector(vibrationData.axis, vibration);
                                });
                            }
                        });
                    }


                    if (particles && particles.visible) {
                        particles.rotation.y += 0.0005;
                        particles.rotation.x += 0.0002;
                    }
                    composer.render();
                }
                animate();

                window.addEventListener('resize', () => {
                    camera.aspect = chamber.clientWidth / chamber.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                    composer.setSize(chamber.clientWidth, chamber.clientHeight);
                });
                chamber.addEventListener('mousemove', onChamberMouseMove, false);
                chamber.addEventListener('mouseleave', () => {
                    moleculeTooltip.classList.remove('show');
                    hoveredMolecule = null;
                });

            } catch (error) {
                console.error("WebGL initialization error:", error);
                chamber.innerHTML = `<div class="webgl-error-message"><h2>Lỗi WebGL</h2><p>Trình duyệt của bạn có thể không hỗ trợ hoặc WebGL đang bị tắt.</p><p><a href="https://get.webgl.org/" target="_blank">Kiểm tra trạng thái WebGL của bạn tại đây</a></p></div>`;
                generateBtn.disabled = true;
                throw new Error("WebGL init failed");
            }
        }

        /**
         * Handles mouse movement on the reaction chamber for molecule tooltip.
         * Uses raycasting to detect hovered atoms and display molecule information.
         * @param {MouseEvent} event - The mousemove event.
         */
        function onChamberMouseMove(event) {
            const rect = chamber.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const allAtomMeshes = molecules.flatMap(molGroup => molGroup.children.filter(c => c.userData.isAtom));
            const intersects = raycaster.intersectObjects(allAtomMeshes);

            if (intersects.length > 0) {
                const parentMoleculeGroup = intersects[0].object.parent;
                if (hoveredMolecule !== parentMoleculeGroup) {
                    hoveredMolecule = parentMoleculeGroup;
                    const data = parentMoleculeGroup.userData.moleculeData;
                    if (data) {
                        let state;
                        switch (data.physicalState?.toLowerCase()) {
                            case 'gas': state = 'Khí'; break;
                            case 'liquid': state = 'Lỏng'; break;
                            case 'solid': state = 'Rắn'; break;
                            case 'aqueous': state = 'Dung dịch'; break;
                            default: state = data.physicalState;
                        }
                        moleculeTooltip.innerHTML = `<strong>${data.molecule}</strong>` +
                            (data.name ? `<br/>Tên: ${data.name}` : '') +
                            (data.molecularWeight ? `<br/>KLPT: ${data.molecularWeight.toFixed(3)} g/mol` : '') +
                            (state ? `<br/>Trạng thái: ${state}` : '');
                        moleculeTooltip.style.left = `${event.clientX + 10}px`;
                        moleculeTooltip.style.top = `${event.clientY + 10}px`;
                        moleculeTooltip.classList.add('show');
                    } else {
                        moleculeTooltip.classList.remove('show');
                    }
                }
            } else if (hoveredMolecule) {
                moleculeTooltip.classList.remove('show');
                hoveredMolecule = null;
            }
        }

        // --- Core Application Logic ---
        const generateBtn = document.getElementById('generate-btn');
        const input = document.getElementById('equation-input');
        const infoText = document.getElementById('info-text');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const speedButtons = document.querySelectorAll('.speed-btn');
        const timelineSlider = document.getElementById('timeline-slider');
        const dragHint = document.getElementById('drag-hint');
        const clearInputBtn = document.getElementById('clear-input-btn');
        const suggestionsList = document.getElementById('suggestions-list');
        const welcomeModalOverlay = document.getElementById('welcome-modal-overlay');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const explanationModeToggle = document.getElementById('explanation-mode-toggle');
        const explanationModalOverlay = document.getElementById('explanation-modal-overlay');
        const explanationTitle = document.getElementById('explanation-title');
        const explanationText = document.getElementById('explanation-text');
        const explanationContinueBtn = document.getElementById('explanation-continue-btn');
        let isExplanationMode = false;
        const atomLegendHeader = document.getElementById('atom-legend-header');
        const atomLegendContent = document.getElementById('atom-legend-content');
        const atomLegendToggle = atomLegendHeader.querySelector('.atom-legend-toggle');
        // NEW: Example Modal Elements
        let examplesBtn, examplesModalOverlay;


        const ATOM_COLORS = [
            { symbol: 'H', color: '#FFFFFF' }, { symbol: 'O', color: '#FF6B6B' }, { symbol: 'C', color: '#333333' },
            { symbol: 'N', color: '#6B9AFF' }, { symbol: 'Fe', color: '#A19D94' }, { symbol: 'S', color: '#FFF36B' },
            { symbol: 'Cl', color: '#6BFF8B' }, { symbol: 'Na', color: '#B06BFF' }, { symbol: 'K', color: '#8A2BE2' },
            { symbol: 'Mg', color: '#BDB76B' }, { symbol: 'Ca', color: '#DDA0DD' }, { symbol: 'Al', color: '#C0C0C0' },
            { symbol: 'P', color: '#FFA500' }, { symbol: 'Br', color: '#A52A2A' }, { symbol: 'I', color: '#4B0082' },
            { symbol: 'Ag', color: '#E0E0E0' }, { symbol: 'Zn', color: '#B0C4DE' }, { symbol: 'Cu', color: '#CD7F32' },
            { symbol: 'Ba', color: '#A9A9A9' }, { symbol: 'F', color: '#8FBC8F' }, { symbol: 'S', color: '#FFD700' },
            { symbol: 'K', color: '#B22222' } // Adding K for Potassium, S for Sulfur (already exists, but for clarity)
        ];
        const COMMON_CHEMICALS = [
            'H2O', 'CO2', 'O2', 'N2', 'H2', 'CH4', 'C2H5OH', 'NaCl', 'HCl', 'H2SO4',
            'NaOH', 'KMnO4', 'NH3', 'CaO', 'Fe2O3', 'SO2', 'NO2', 'C6H12O6', 'C12H22O11',
            'AgNO3', 'BaCl2', 'CuSO4', 'FeCl3', 'KClO3', 'CaCO3', 'CH2=CH2', 'CH=CH',
            'C2H6', 'CH3COOH', 'Na2SO4', 'NaHCO3' // Adding common chemicals from example reactions
        ];
        let currentMessageTimeout;

        function displayMessage(message, isError = false) {
            if (currentMessageTimeout) clearTimeout(currentMessageTimeout);
            infoText.textContent = message;
            infoText.classList.toggle('error-message', isError);
            gsap.to(infoText, { opacity: 1, duration: 0.3 });
            if (!isError) {
                currentMessageTimeout = setTimeout(() => gsap.to(infoText, { opacity: 0, duration: 0.5 }), 5000);
            }
        }
        function toggleDragHint(show) { if (dragHint) dragHint.classList.toggle('show', show); }

        function clearScene() {
            molecules.forEach(m => {
                m.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(m);
            });
            scene.children
                .filter(obj => obj.userData.isEffect || obj.userData.isGasBubble || obj.userData.isPrecipitationParticle)
                .forEach(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                    scene.remove(obj);
                });
            molecules = [];
            if (solutionContainer) {
                solutionContainer.material.color.set(0x000000);
                solutionContainer.material.opacity = 0.0;
                solutionContainer.visible = false;
            }
        }

        /**
         * Draws a 3D representation of a molecule.
         * @param {object} moleculeDef - Definition of the molecule, including atoms and bonds.
         * @param {number} x - X coordinate for the molecule's position.
         * @param {number} y - Y coordinate for the molecule's position.
         * @param {number} z - Z coordinate for the molecule's position.
         * @returns {THREE.Group} - The THREE.Group object representing the molecule.
         */
        function drawMolecule3D(moleculeDef, x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const atomRadius = 0.5;
            const bondThickness = 0.1;
            const atomMeshes = moleculeDef.atoms.map((atomDef, i) => {
                const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(atomDef.color), metalness: 0.4, roughness: 0.4,
                    transparent: true, emissive: new THREE.Color(0x000000)
                });
                const atomMesh = new THREE.Mesh(geometry, material);
                if (moleculeDef.atoms.length > 1) {
                    const angle = (i / moleculeDef.atoms.length) * 2 * Math.PI;
                    const spreadRadius = atomRadius * 1.5;
                    atomMesh.position.set(Math.cos(angle) * spreadRadius, Math.sin(angle) * spreadRadius, (Math.random() - 0.5) * atomRadius * 0.5);
                }
                atomMesh.userData = { isAtom: true, symbol: atomDef.symbol };
                group.add(atomMesh);
                return atomMesh;
            });

            const bondMeshes = [];
            // Ensure bonds array exists before iterating
            if (moleculeDef.bonds && Array.isArray(moleculeDef.bonds)) {
                moleculeDef.bonds.forEach(bond => {
                    const atomA = atomMeshes[bond.atom1Index];
                    const atomB = atomMeshes[bond.atom2Index];
                    if (atomA && atomB) {
                        const posA = atomA.position, posB = atomB.position;
                        const distance = posA.distanceTo(posB);
                        const midPoint = new THREE.Vector3().addVectors(posA, posB).divideScalar(2);
                        const direction = new THREE.Vector3().subVectors(posB, posA).normalize();
                        let perp = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                        if (perp.lengthSq() < 1e-4) perp.set(1, 0, 0).crossVectors(direction, perp).normalize();
                        
                        let segments = 1, offset = 0;
                        switch (bond.bondType) {
                            case 'double': segments = 2; offset = bondThickness * 0.5; break;
                            case 'triple': segments = 3; offset = bondThickness * 0.7; break;
                        }
                        for (let i = 0; i < segments; i++) {
                            const geom = new THREE.CylinderGeometry(bondThickness, bondThickness, distance, 8);
                            const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.2, roughness: 0.6, transparent: true });
                            const mesh = new THREE.Mesh(geom, mat);
                            mesh.position.copy(midPoint);
                            mesh.lookAt(posB);
                            mesh.rotation.x += Math.PI / 2;
                            if (segments > 1) mesh.position.add(perp.clone().multiplyScalar((i - (segments - 1) / 2) * offset));
                            mesh.userData.isBond = true;
                            group.add(mesh);
                            bondMeshes.push(mesh);
                        }
                    }
                });
            }
            group.userData.moleculeData = { ...moleculeDef, atoms: atomMeshes, bondMeshes: bondMeshes };
            scene.add(group);
            molecules.push(group);
            return group;
        }

        /**
         * Creates and animates gas bubbles.
         * @param {object} options - Options for gas bubbles (color, count, size, origin).
         */
        function createGasBubbles(options) {
            const defaultColor = '#ADD8E6';
            const defaultCount = 30;
            const defaultSize = 0.1;
            const defaultOrigin = { x: 0, y: -5, z: 0 };
            const bubbleColor = options.gas_color || defaultColor;
            const bubbleCount = options.bubble_count || defaultCount;
            const bubbleSize = options.bubble_size || defaultSize;
            const originPoint = options.origin_point || defaultOrigin;
            const bubbleGeometry = new THREE.SphereGeometry(bubbleSize, 16, 16);
            const bubbleMaterial = new THREE.MeshBasicMaterial({ color: bubbleColor, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            for (let i = 0; i < bubbleCount; i++) {
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial.clone());
                bubble.position.set(originPoint.x + (Math.random() - 0.5) * 2, originPoint.y + (Math.random() * 2), originPoint.z + (Math.random() - 0.5) * 2);
                bubble.userData.isGasBubble = true;
                scene.add(bubble);
                gsap.to(bubble.position, {
                    y: originPoint.y + 15 + Math.random() * 5, x: bubble.position.x + (Math.random() - 0.5) * 3,
                    duration: 3 + Math.random() * 2, ease: "none",
                    onComplete: () => gsap.to(bubble.material, { opacity: 0, duration: 0.5, onComplete: () => { bubble.geometry.dispose(); bubble.material.dispose(); scene.remove(bubble); } })
                });
            }
        }

        /**
         * Creates and animates precipitation particles.
         * @param {object} options - Options for precipitation (color, density, formation area).
         */
        function createPrecipitationParticles(options) {
            const defaultColor = '#C0C0C0';
            let particleCount = 200, particleSize = 0.08, startY = 5, endY = -5, spread = 5;
            const precipitationColor = options.color || defaultColor;
            const formationArea = options.formation_area || 'bottom';
            switch (options.density || 'medium') {
                case 'light': particleCount = 100; particleSize = 0.05; break;
                case 'heavy': particleCount = 400; particleSize = 0.12; break;
            }
            const precipitationGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
            const precipitationMaterial = new THREE.MeshBasicMaterial({ color: precipitationColor, transparent: true, opacity: 0 });
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(precipitationGeometry, precipitationMaterial.clone());
                particle.position.set((Math.random() - 0.5) * spread, startY + (Math.random() * 2 - 1) * 2, (Math.random() - 0.5) * spread);
                particle.userData.isPrecipitationParticle = true;
                scene.add(particle);
                const finalY = (formationArea === 'bottom') ? endY + (Math.random() * 2 - 1) * 0.5 : (Math.random() * 2 - 1) * 1;
                gsap.timeline({ delay: Math.random() * 0.5 })
                    .to(particle.material, { opacity: 0.8, duration: 1 })
                    .to(particle.position, { y: finalY, duration: 2 + Math.random() * 2, ease: "power1.inOut" }, "<");
            }
        }

        /**
         * Validates the structure of the reaction plan received from the AI.
         * @param {object} plan - The reaction plan object.
         * @returns {boolean} - True if the plan is valid, throws an error otherwise.
         */
        function validateReactionPlan(plan) {
            if (!plan || typeof plan !== 'object') throw new Error("Phản hồi AI không phải là đối tượng hợp lệ.");
            if (!plan.title || typeof plan.title !== 'string') throw new Error("Thiếu 'title' trong phản hồi AI.");
            if (!Array.isArray(plan.reactants)) throw new Error("Thiếu 'reactants' trong phản hồi AI.");
            if (!Array.isArray(plan.products)) throw new Error("Thiếu 'products' trong phản hồi AI.");
            if (typeof plan.isExothermic !== 'boolean') throw new Error("Thiếu trường 'isExothermic' trong phản hồi AI.");
            const allSubstances = [...plan.reactants, ...plan.products];
            for(const sub of allSubstances){
                if (!Array.isArray(sub.bonds)) throw new Error(`Chất ${sub.molecule} thiếu trường 'bonds' bắt buộc.`);
            }
            return true;
        }


        // --- Animation Engine (UPDATED) ---
        /**
         * Runs the chemical reaction animation based on the provided plan.
         * This version implements the "Chemical Supernova" concept.
         * @param {object} plan - The reaction plan object generated by the AI.
         */
        function runAnimation(plan) {
            if (mainTimeline) mainTimeline.kill();
            clearScene();
            
            if (particles) {
                particles.visible = true;
                const positions = particles.geometry.attributes.position.array;
                const originalPositions = particles.geometry.userData.originalPositions;
                for (let i = 0; i < originalPositions.length; i++) {
                    positions[i] = originalPositions[i];
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
            toggleDragHint(false);
            moleculeTooltip.classList.remove('show');
            hideExplanationModal();
            displayMessage(`Đang chuẩn bị: ${plan.title}`);
            updateAtomLegend(plan);

            mainTimeline = gsap.timeline({
                onUpdate: () => {
                    timelineSlider.value = mainTimeline.progress() * 100;
                    if (!isExplanationMode) playPauseBtn.textContent = mainTimeline.paused() ? "▶️" : "⏸️";
                },
                onComplete: () => {
                    displayMessage("Hoạt ảnh hoàn tất!");
                    playPauseBtn.innerHTML = `<span class="material-icons">replay</span>`; // Change to replay icon
                    restartBtn.disabled = false;
                    timelineSlider.disabled = true;
                    if (particles) particles.visible = true;
                    toggleDragHint(true);
                }
            });

            [playPauseBtn, restartBtn, timelineSlider, explanationModeToggle, ...speedButtons].forEach(el => el.disabled = false);
            playPauseBtn.innerHTML = `<span class="material-icons">pause</span>`;

            const reactantGroups = [];
            const baseMultiplier = 2; // For more molecules
            plan.reactants.forEach(r => {
                for (let j = 0; j < Math.max(1, r.count) * baseMultiplier; j++) {
                    const x = (Math.random() - 0.5) * 16 + (j % 2 === 0 ? -4 : 4);
                    const y = (Math.random() - 0.5) * 8;
                    const z = (Math.random() - 0.5) * 8;
                    reactantGroups.push(drawMolecule3D(r, x, y, z));
                }
            });
            
            plan.animationSteps.forEach((step, stepIndex) => {
                const stepTimeline = gsap.timeline();
                step.plan = plan;
                switch(step.type) {
                    case 'move_to_center': {
                        const DURATION = step.duration;
                        stepTimeline.to(camera.position, { z: 25, duration: DURATION, ease: "power2.inOut"}, 0);
                        
                        const ambientLight = scene.getObjectByName("ambientLight");
                        const directionalLight = scene.getObjectByName("directionalLight");
                        if(ambientLight) stepTimeline.to(ambientLight, { intensity: 0.1, duration: DURATION * 0.8 }, 0);
                        if(directionalLight) stepTimeline.to(directionalLight, { intensity: 0.2, duration: DURATION * 0.8 }, 0);
                        
                        reactantGroups.forEach(group => {
                            stepTimeline.to(group.position, {
                                x: (Math.random() - 0.5) * 6, y: (Math.random() - 0.5) * 6, z: (Math.random() - 0.5) * 6,
                                duration: DURATION, ease: "power2.inOut"
                            }, 0);
                            stepTimeline.to(group.rotation, { x: '+=6', y: '+=6', duration: DURATION, ease: "power1.inOut" }, 0);
                            stepTimeline.to(group.rotation, { x: '+=0.2', y: '-=0.2', z: '+=0.2', duration: 0.5, ease: `rough({ strength: 2, points: 20 })`, yoyo: true, repeat: 3}, DURATION - 1.5);
                        });
                        break;
                    }
                    case 'disintegrate': {
                        const DURATION = step.duration;
                        stepTimeline.addLabel("disintegration");
                        reactantGroups.forEach(group => {
                            const atoms = group.userData.moleculeData.atoms;
                            const bonds = group.userData.moleculeData.bondMeshes;

                            bonds.forEach(bond => {
                                stepTimeline.to(bond.scale, { x: 0.1, y: 0.1, z: 0.1, duration: DURATION * 0.5, ease: "power2.in" }, "disintegration");
                                stepTimeline.to(bond.material, { opacity: 0, duration: DURATION * 0.5 }, "disintegration");
                            });
                            
                            atoms.forEach(atom => {
                                stepTimeline.to(atom.material.emissive, { r: 0.2, g: 0.2, b: 0.2, duration: DURATION }, "disintegration");
                                stepTimeline.to(atom.position, {
                                    x: atom.position.x * 1.5, y: atom.position.y * 1.5, z: atom.position.z * 1.5,
                                    duration: DURATION, ease: "power1.out"
                                }, "disintegration");
                            });
                        });
                        break;
                    }
                    case 'maelstrom': {
                        const DURATION = step.duration;
                        stepTimeline.addLabel("vortex");
                        const allAtoms = [];
                        reactantGroups.forEach(group => {
                            group.userData.moleculeData.atoms.forEach(atom => {
                                const worldPos = new THREE.Vector3(); atom.getWorldPosition(worldPos);
                                scene.add(atom); atom.position.copy(worldPos); allAtoms.push(atom);
                            });
                            scene.remove(group);
                        });
                        reactantGroups.length = 0; // Clear reactant groups as atoms are now individual

                        allAtoms.forEach(atom => {
                            stepTimeline.to(atom.position, {
                                x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5, z: (Math.random() - 0.5) * 5,
                                duration: DURATION, ease: "power2.inOut"
                            }, "vortex");
                            stepTimeline.to(atom.rotation, { y: "+=10", duration: DURATION }, "vortex");
                            stepTimeline.to(atom.material.emissive, { r: 0.6, g: 0.6, b: 0.3, duration: DURATION }, "vortex");
                        });
                        stepTimeline.to(camera.rotation, { z: '+=0.5', duration: DURATION, ease: "power1.inOut" }, "vortex");
                        break;
                    }
                    case 'supernova': {
                        const REACTION_CENTER = new THREE.Vector3(0, 0, 0);
                        const DURATION = step.duration;
                        stepTimeline.addLabel("detonation", "+=0");
                        stepTimeline.to(camera.position, { z: 18, duration: DURATION * 0.2, ease: "power3.in" }, "detonation");
                        
                        const shake = { strength: 0.3 };
                        stepTimeline.to(shake, {
                            strength: 0, duration: 1.2,
                            onUpdate: () => {
                                camera.position.x += (Math.random() - 0.5) * shake.strength;
                                camera.position.y += (Math.random() - 0.5) * shake.strength;
                            }
                        }, "detonation");

                        stepTimeline.add(() => {
                            const coreFlash = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, blending: THREE.AdditiveBlending }));
                            coreFlash.userData.isEffect = true; scene.add(coreFlash);
                            gsap.to(coreFlash.scale, { x: 25, y: 25, z: 25, duration: 0.5, ease: "power2.out" });
                            gsap.to(coreFlash.material, { opacity: 0, duration: 0.7, ease: "power2.out", onComplete: () => { coreFlash.geometry.dispose(); coreFlash.material.dispose(); scene.remove(coreFlash); } });
                            
                            const shockwaveColor = plan.isExothermic ? 0xffa500 : 0x87ceeb;
                            const shockwave = new THREE.Mesh(new THREE.TorusGeometry(1, 0.2, 16, 100), new THREE.MeshBasicMaterial({ color: shockwaveColor, transparent: true, opacity: 0.8 }));
                            shockwave.rotation.x = Math.PI / 2; shockwave.userData.isEffect = true; scene.add(shockwave);
                            gsap.to(shockwave.scale, { x: 40, y: 40, z: 40, duration: 2.0, ease: "power1.out" });
                            gsap.to(shockwave.material, { opacity: 0, duration: 2.0, ease: "power1.out", onComplete: () => { shockwave.geometry.dispose(); shockwave.material.dispose(); scene.remove(shockwave); } });
                        }, "detonation+=0.05");

                        stepTimeline.addLabel("supernova", "detonation+=0.2");
                        const detachedAtoms = scene.children.filter(c => c.userData && c.userData.isAtom);
                        
                        const ringGeo = new THREE.TorusGeometry(10, 0.15, 16, 100);
                        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
                        const energyRing = new THREE.Mesh(ringGeo, ringMat);
                        energyRing.rotation.x = Math.PI / 2; energyRing.userData.isEffect = true; scene.add(energyRing);
                        stepTimeline.to(energyRing.scale, { x: 1.5, y: 1.5, z: 1.5, duration: DURATION * 0.9, ease: "power1.out"}, "supernova")
                        stepTimeline.to(energyRing.material, { opacity: 0.7, duration: 1.5, ease: "power1.out" }, "supernova");
                        stepTimeline.to(energyRing.rotation, { z: "+=5", duration: DURATION * 0.9 }, "supernova");
                        stepTimeline.to(energyRing.material, { opacity: 0, duration: 1.5, ease: "power1.in", onComplete: () => { energyRing.geometry.dispose(); energyRing.material.dispose(); scene.remove(energyRing); } }, `supernova+=${DURATION*0.9 - 1.5}`);

                        detachedAtoms.forEach(atom => {
                            stepTimeline.to(atom.position, {
                                x: (Math.random() - 0.5) * 25, y: (Math.random() - 0.5) * 25, z: (Math.random() - 0.5) * 25,
                                duration: DURATION * 0.7, ease: "power2.out"
                            }, "supernova");
                            stepTimeline.to(atom.material.emissive, { r: 1.5, g: 1.5, b: 0.8, duration: DURATION * 0.6, ease: "power2.in" }, "supernova");
                        });
                        break;
                    }
                    case 'reform': {
                        const DURATION = step.duration;
                        stepTimeline.addLabel("reformation", "+=0");
                        const atomPool = {};
                        scene.children.filter(c => c.userData && c.userData.isAtom).forEach(atom => {
                            const symbol = atom.userData.symbol;
                            if (!atomPool[symbol]) atomPool[symbol] = [];
                            atomPool[symbol].push(atom);
                        });

                        const totalProductInstances = plan.products.reduce((acc, p) => acc + (p.count * baseMultiplier), 0);
                        let productIndex = 0;

                        plan.products.forEach(p => {
                            for (let j = 0; j < Math.max(1, p.count) * baseMultiplier; j++) {
                                const angle = (productIndex / totalProductInstances) * Math.PI * 4;
                                const radius = 5 + (productIndex / totalProductInstances) * 10;
                                const x = Math.cos(angle) * radius, y = Math.sin(angle) * radius, z = (Math.random() - 0.5) * 6;
                                const productGroup = drawMolecule3D(p, x, y, z);
                                
                                productGroup.userData.moleculeData.drift = new THREE.Vector3((Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.01);
                                productGroup.userData.moleculeData.rotationSpeed = new THREE.Vector3((Math.random() - 0.5) * 0.005, (Math.random() - 0.5) * 0.005, (Math.random() - 0.5) * 0.005);
                                productGroup.userData.moleculeData.originalAtomPositions = productGroup.userData.moleculeData.atoms.map(atom => atom.position.clone());
                                productGroup.userData.moleculeData.vibrationParams = productGroup.userData.moleculeData.atoms.map(() => ({
                                    speed: 0.5 + Math.random() * 1.5, phase: Math.random() * Math.PI * 2, axis: new THREE.Vector3().randomDirection()
                                }));

                                productGroup.traverse(child => { if(child.isMesh) child.material.opacity = 0; });
                                
                                productGroup.userData.moleculeData.atoms.forEach(targetAtom => {
                                    const sourceAtom = atomPool[targetAtom.userData.symbol]?.pop();
                                    if(sourceAtom){
                                        const targetWorldPos = new THREE.Vector3(); targetAtom.getWorldPosition(targetWorldPos);
                                        stepTimeline.to(sourceAtom.position, { x: targetWorldPos.x, y: targetWorldPos.y, z: targetWorldPos.z, duration: DURATION * 0.4, ease: "power3.inOut" }, "reformation");
                                        stepTimeline.to(sourceAtom.material, { opacity: 0, duration: DURATION * 0.4 }, "reformation");
                                        stepTimeline.to(sourceAtom.material.emissive, { r:0, g:0, b:0, duration: DURATION * 0.4 }, "reformation");
                                        stepTimeline.add(()=> { sourceAtom.geometry.dispose(); sourceAtom.material.dispose(); scene.remove(sourceAtom); }, `reformation+=${DURATION*0.4}`);
                                    }
                                });

                                productGroup.traverse(child => { if (child.isMesh) stepTimeline.to(child.material, { opacity: 1, duration: DURATION * 0.3 }, `reformation+=${DURATION*0.1}`); });
                                productIndex++;
                            }
                        });
                        // Remove any remaining unutilized atoms
                        Object.values(atomPool).flat().forEach(atom => stepTimeline.to(atom.material, {opacity: 0, duration: 0.5, onComplete: ()=> { atom.geometry.dispose(); atom.material.dispose(); scene.remove(atom); }}, 'reformation'));
                        break;
                    }
                    case 'aftermath': {
                        const DURATION = step.duration;
                        stepTimeline.addLabel("breathing", "+=0");
                        molecules.forEach(group => {
                            const emissiveTargets = group.userData.moleculeData.atoms.map(a => a.material.emissive);
                            stepTimeline.to(emissiveTargets, { r: 0.8, g: 0.8, b: 0.4, duration: 1.5, yoyo: true, repeat: 5, ease: "sine.inOut" }, `breathing`);
                        });
                        const ambientLight = scene.getObjectByName("ambientLight");
                        const directionalLight = scene.getObjectByName("directionalLight");
                        if(ambientLight) stepTimeline.to(ambientLight, { intensity: 0.5, duration: DURATION }, "breathing");
                        if(directionalLight) stepTimeline.to(directionalLight, { intensity: 1.0, duration: DURATION }, "breathing");
                        stepTimeline.to(camera.position, { z: 25, duration: DURATION }, "breathing");
                        break;
                    }
                    case 'gas_evolution':
                        stepTimeline.add(() => createGasBubbles(step.options || {}));
                        break;

                    case 'precipitation':
                        stepTimeline.add(() => createPrecipitationParticles(step.options || {}));
                        break;
                }
                
                mainTimeline.add(stepTimeline);
                mainTimeline.add(() => {
                    if (isExplanationMode) {
                        mainTimeline.pause();
                        showExplanationModal(step.text || `Bước...`, step.explanation, stepIndex + 1);
                    } else { displayMessage(step.text || '...'); }
                }, ">");
            });
        }

        /**
         * Generates the reaction plan by calling the AI model and then runs the animation. (UPDATED)
         */
        async function generateReactionPlan() {
            if (!model || !renderer) {
                displayMessage("Lỗi: Engine AI hoặc môi trường 3D chưa sẵn sàng.", true);
                return;
            }
            const userInput = input.value.trim();
            if (!userInput) {
                displayMessage("Vui lòng nhập các chất tham gia để tạo phản ứng.", true);
                input.classList.add('input-error');
                updateAtomLegend(null);
                return;
            }
            input.classList.remove('input-error');

            displayMessage('AI đang tư duy... 🧠');
            [generateBtn, playPauseBtn, restartBtn, timelineSlider, explanationModeToggle, ...speedButtons].forEach(el => el.disabled = true);
            loadingSpinner.classList.remove('hidden');
            clearInputBtn.classList.add('hidden');
            moleculeTooltip.classList.remove('show');
            hideExplanationModal();
            if (particles) particles.visible = false;
            toggleDragHint(false);
            updateAtomLegend(null);

            // Final, most robust prompt for the AI model
            const prompt = `
            Dựa trên các chất tham gia: "${userInput}".
            Hãy dự đoán sản phẩm hóa học và cân bằng phương trình.
            Sau đó, tạo một đối tượng JSON tuân thủ cấu trúc sau:

            CẤU TRÚC JSON BẮT BUỘC:
            - "title": (string) Phương trình hóa học đầy đủ và cân bằng.
            - "isExothermic": (boolean) Là true nếu phản ứng tỏa nhiệt, false nếu thu nhiệt. Đây là trường BẮT BUỘC.
            - "reactants": (array) Một mảng các đối tượng chất phản ứng.
            - "products": (array) Một mảng các đối tượng sản phẩm.
            
            QUY TẮC CHO MỖI ĐỐI TƯỢNG CHẤT TRONG "reactants" VÀ "products":
            Mỗi đối tượng chất phải có các trường sau:
            - "molecule": (string) Công thức hóa học của chất (ví dụ: "H2O", "C6H12O6").
            - "name": (string) Tên gọi thông thường của chất (ví dụ: "Nước", "Glucose").
            - "count": (number) Số mol/hệ số của chất trong phương trình cân bằng.
            - "molecularWeight": (number) Khối lượng phân tử của chất.
            - "physicalState": (string) Trạng thái vật lý ("gas", "liquid", "solid", "aqueous").
            - "atoms": (array) Mảng các đối tượng nguyên tử. Mỗi nguyên tử có:
                - "symbol": (string) Ký hiệu nguyên tử (ví dụ: "H", "O", "C").
                - "color": (string) Mã màu Hex của nguyên tử.
            - "bonds": (array) **QUY TẮC TỐI QUAN TRỌNG**: Mảng các đối tượng liên kết.
                - Nếu chất có nhiều hơn một nguyên tử, "bonds" phải chứa các đối tượng liên kết:
                    - "atom1Index": (number) Chỉ số của nguyên tử thứ nhất trong mảng "atoms" (bắt đầu từ 0).
                    - "atom2Index": (number) Chỉ số của nguyên tử thứ hai trong mảng "atoms" (bắt đầu từ 0).
                    - "bondType": (string) Loại liên kết ("single", "double", "triple").
                - Nếu chất chỉ có MỘT nguyên tử (ví dụ: Fe, Na, Cu), "bonds" PHẢI là một mảng rỗng: "bonds": [].
                - TUYỆT ĐỐI không được bỏ qua trường "bonds" hoặc trả về null cho "bonds".

            Sử dụng các màu sau cho nguyên tử (tùy chỉnh hoặc thêm nếu cần):
            H: #FFFFFF, O: #FF6B6B, C: #333333, N: #6B9AFF, Fe: #A19D94, S: #FFF36B, Cl: #6BFF8B, Na: #B06BFF, K: #8A2BE2, Mg: #BDB76B, Ca: #DDA0DD, Al: #C0C0C0, P: #FFA500, Br: #A52A2A, I: #4B0082, Ag: #E0E0E0, Zn: #B0C4DE, Cu: #CD7F32, Ba: #A9A9A9, F: #8FBC8F.

            Chỉ trả lời bằng một khối mã JSON hợp lệ duy nhất. Đảm bảo JSON có thể phân tích cú pháp được.
            `;

            try {
                const result = await model.generateContent(prompt);
                const textResponse = result.response.text();
                let plan;
                try {
                    // Extract JSON object from the response using regex, in case it's wrapped in text
                    const jsonMatch = textResponse.match(/{[\s\S]*}/);
                    if (!jsonMatch) {
                        throw new Error("Không tìm thấy đối tượng JSON trong phản hồi của AI.");
                    }
                    plan = JSON.parse(jsonMatch[0]);
                    
                    // Manually add animation steps since we removed it from the prompt for AI simplicity
                    plan.animationSteps = [
                        { type: "move_to_center", duration: 3.5, text: "Giai đoạn 1: Tụ Bão", explanation: "Các chất phản ứng được hút vào vùng trung tâm, tích tụ năng lượng và bắt đầu va chạm." },
                        { type: "disintegrate", duration: 1.5, text: "Giai đoạn 2: Phân rã", explanation: "Liên kết giữa các nguyên tử trong chất phản ứng bị phá vỡ do năng lượng va chạm, giải phóng các nguyên tử tự do." },
                        { type: "maelstrom", duration: 2.5, text: "Giai đoạn 3: Hỗn Nguyên", explanation: "Các nguyên tử tự do di chuyển hỗn loạn, tạo thành một 'vũng' năng lượng cao sẵn sàng tái cấu trúc." },
                        { type: "supernova", duration: 2.0, text: "Giai đoạn 4: Kích Nổ", explanation: "Năng lượng tích lũy đạt đỉnh, giải phóng trong một 'vụ nổ' mạnh mẽ, cho phép hình thành liên kết mới." },
                        { type: "reform", duration: 3.0, text: "Giai đoạn 5: Tái tạo", explanation: "Các nguyên tử va chạm và tạo thành các liên kết mới, sắp xếp lại để hình thành các phân tử sản phẩm." },
                        { type: "aftermath", duration: 3.0, text: "Giai đoạn 6: Dư Âm", explanation: "Các phân tử sản phẩm đã hình thành ổn định, giải phóng năng lượng dư thừa và di chuyển tự do trong hệ thống." }
                    ];
                    
                    // Automatically detect and add special effect steps
                    const gasProduct = plan.products.find(p => p.physicalState?.toLowerCase() === 'gas');
                    // A solid product formed from non-solid reactants
                    const precipitateProduct = plan.products.find(p => p.physicalState?.toLowerCase() === 'solid' && plan.reactants.every(r => r.physicalState?.toLowerCase() !== 'solid'));

                    if (gasProduct) {
                        plan.animationSteps.push({ type: 'gas_evolution', text: "Sản phẩm khí được giải phóng dưới dạng bong bóng.", explanation: `${gasProduct.name} (khí) bay lên, tạo thành các bong bóng khí đặc trưng cho phản ứng.`, options: {} });
                    }
                    if (precipitateProduct) {
                        plan.animationSteps.push({ type: 'precipitation', text: "Kết tủa được hình thành.", explanation: `${precipitateProduct.name} (rắn) kết tủa và lắng xuống dưới dung dịch.`, options: { color: precipitateProduct.atoms[0].color } });
                    }

                } catch (jsonError) {
                    console.error("Lỗi parsing JSON:", jsonError, "Phản hồi thô:", textResponse);
                    throw new Error("Phản hồi của AI không phải là JSON hợp lệ hoặc thiếu dữ liệu.");
                }
                validateReactionPlan(plan); // Validate the plan before running animation
                runAnimation(plan);
            } catch (error) {
                console.error("Lỗi:", error);
                displayMessage(`Lỗi: ${error.message}`, true);
                if (particles) particles.visible = true;
                toggleDragHint(true);
            } finally {
                generateBtn.disabled = false;
                loadingSpinner.classList.add('hidden');
                if (input.value.length > 0) clearInputBtn.classList.remove('hidden');
            }
        }

        // --- UI and Event Listeners ---
        /** Updates the visual state of the input field (clear button, validation styles). */
        function updateInputState() {
            const value = input.value.trim();
            clearInputBtn.classList.toggle('hidden', value.length === 0);
            input.classList.remove('input-error', 'input-valid');
            if (value.length > 0) {
                if (/^[A-Za-z0-9\s\+->]*$/.test(value)) {
                    input.classList.add('input-valid');
                } else {
                    input.classList.add('input-error');
                }
            }
        }

        /** Shows chemical suggestions based on user input. */
        function showSuggestions(query) {
            suggestionsList.innerHTML = '';
            if (query.length < 1) {
                suggestionsList.classList.remove('show');
                return;
            }
            const filteredSuggestions = COMMON_CHEMICALS.filter(chem => chem.toLowerCase().includes(query.toLowerCase()));
            if (filteredSuggestions.length > 0) {
                filteredSuggestions.forEach(suggestion => {
                    const item = document.createElement('div');
                    item.classList.add('suggestion-item');
                    item.textContent = suggestion;
                    item.addEventListener('click', () => {
                        input.value = suggestion;
                        suggestionsList.classList.remove('show');
                        updateInputState();
                    });
                    suggestionsList.appendChild(item);
                });
                suggestionsList.classList.add('show');
            } else {
                suggestionsList.classList.remove('show');
            }
        }

        input.addEventListener('input', () => { updateInputState(); showSuggestions(input.value); });
        document.addEventListener('click', (e) => { if (!input.contains(e.target) && !suggestionsList.contains(e.target)) suggestionsList.classList.remove('show'); });
        clearInputBtn.addEventListener('click', () => { input.value = ''; updateInputState(); suggestionsList.classList.remove('show'); displayMessage("Đầu vào đã được xóa."); });
        playPauseBtn.addEventListener('click', () => {
            if (mainTimeline) {
                if (mainTimeline.paused()) {
                    mainTimeline.resume();
                    playPauseBtn.innerHTML = `<span class="material-icons">pause</span>`;
                } else if (mainTimeline.progress() === 1) { // If animation is complete, restart
                    mainTimeline.restart();
                    playPauseBtn.innerHTML = `<span class="material-icons">pause</span>`;
                } else {
                    mainTimeline.pause();
                    playPauseBtn.innerHTML = `<span class="material-icons">play_arrow</span>`;
                }
                if (isExplanationMode) hideExplanationModal();
            }
        });
        restartBtn.addEventListener('click', () => { if (mainTimeline) mainTimeline.restart(); hideExplanationModal(); });
        speedButtons.forEach(button => button.addEventListener('click', (e) => {
            const speed = parseFloat(e.target.dataset.speed);
            if (mainTimeline) mainTimeline.timeScale(speed);
            speedButtons.forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
        }));
        timelineSlider.addEventListener('input', () => { if (mainTimeline) { mainTimeline.progress(timelineSlider.value / 100).pause(); if (isExplanationMode) hideExplanationModal(); } });
        modalCloseBtn.addEventListener('click', hideWelcomeModal);
        atomLegendHeader.addEventListener('click', () => {
            atomLegendContent.classList.toggle('expanded');
            atomLegendToggle.style.transform = atomLegendContent.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)';
        });
        explanationModeToggle.addEventListener('click', () => {
            isExplanationMode = !isExplanationMode;
            explanationModeToggle.classList.toggle('active', isExplanationMode);
            displayMessage(`Chế độ Giải thích: ${isExplanationMode ? 'BẬT' : 'TẮT'}`);
            if (isExplanationMode && mainTimeline && !mainTimeline.isActive()) mainTimeline.restart();
            else if (!isExplanationMode && mainTimeline && mainTimeline.paused()) { mainTimeline.resume(); hideExplanationModal(); }
        });
        explanationContinueBtn.addEventListener('click', () => { if (mainTimeline) { mainTimeline.resume(); hideExplanationModal(); } });

        /** Shows the welcome modal on first visit. */
        function showWelcomeModal() {
            const hasVisited = localStorage.getItem('hasVisitedChemicalAIApp');
            if (!hasVisited) {
                welcomeModalOverlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            } else {
                initApp();
            }
        }
        /** Hides the welcome modal and initializes the app. */
        function hideWelcomeModal() {
            welcomeModalOverlay.classList.remove('show');
            localStorage.setItem('hasVisitedChemicalAIApp', 'true');
            document.body.style.overflow = '';
            initApp();
        }

        // NEW: Functions for Example Modal
        /** Creates and appends the examples modal to the DOM. */
        function createExamplesModal() {
            const modalStyle = `
                .examples-modal-overlay {
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
                    display: flex; align-items: center; justify-content: center;
                    z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
                }
                .examples-modal-overlay.show { opacity: 1; pointer-events: auto; }
                .examples-modal-content {
                    background: #2a2a3e; border: 1px solid #4a4a6a;
                    padding: 2rem; border-radius: 12px;
                    width: 90%; max-width: 800px; max-height: 80vh;
                    overflow-y: auto; position: relative;
                    transform: scale(0.95); transition: transform 0.3s ease;
                }
                .examples-modal-overlay.show .examples-modal-content { transform: scale(1); }
                .examples-modal-close-btn {
                    position: absolute; top: 1rem; right: 1rem;
                    background: none; border: none; font-size: 1.5rem;
                    color: #888; cursor: pointer; transition: color 0.2s;
                }
                .examples-modal-close-btn:hover { color: #fff; }
                .reaction-category { margin-bottom: 1.5rem; }
                .reaction-category h3 { font-size: 1.1rem; font-weight: 500; color: #a0a0c0; margin-bottom: 0.75rem; border-bottom: 1px solid #4a4a6a; padding-bottom: 0.5rem; }
                .reaction-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 0.75rem; }
                .reaction-item {
                    background: #3a3a5a; padding: 0.75rem 1rem; border-radius: 6px;
                    cursor: pointer; transition: background 0.2s, transform 0.2s;
                    font-family: 'Courier New', Courier, monospace;
                    word-break: break-all; /* Ensure long equations wrap */
                }
                .reaction-item:hover { background: #4a4a7a; transform: translateY(-2px); }
            `;
            const styleSheet = document.createElement("style");
            styleSheet.type = "text/css";
            styleSheet.innerText = modalStyle;
            document.head.appendChild(styleSheet);

            examplesModalOverlay = document.createElement('div');
            examplesModalOverlay.className = 'examples-modal-overlay';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'examples-modal-content';

            const closeBtn = document.createElement('button');
            closeBtn.className = 'examples-modal-close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => examplesModalOverlay.classList.remove('show');

            const title = document.createElement('h2');
            title.textContent = 'Chọn một phản ứng ví dụ';
            
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(title);

            exampleReactions.forEach(cat => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'reaction-category';
                
                const categoryTitle = document.createElement('h3');
                categoryTitle.innerHTML = cat.category;
                categoryDiv.appendChild(categoryTitle);

                const listDiv = document.createElement('div');
                listDiv.className = 'reaction-list';

                cat.reactions.forEach(reaction => {
                    const item = document.createElement('div');
                    item.className = 'reaction-item';
                    item.textContent = reaction.name;
                    item.dataset.input = reaction.input;
                    item.onclick = (event) => {
                        input.value = event.currentTarget.dataset.input;
                        updateInputState();
                        examplesModalOverlay.classList.remove('show');
                        displayMessage(`Đã chọn ví dụ: ${event.currentTarget.dataset.input}`);
                    };
                    listDiv.appendChild(item);
                });
                categoryDiv.appendChild(listDiv);
                modalContent.appendChild(categoryDiv);
            });

            examplesModalOverlay.appendChild(modalContent);
            document.body.appendChild(examplesModalOverlay);
            
            examplesModalOverlay.addEventListener('click', (event) => {
                if (event.target === examplesModalOverlay) {
                    examplesModalOverlay.classList.remove('show');
                }
            });
        }

        /** Initializes the main application components. */
        function initApp() {
            init3D();
            generateBtn.addEventListener('click', generateReactionPlan);
            
            // NEW: Create and setup example button and modal
            createExamplesModal();
            examplesBtn = document.createElement('button');
            examplesBtn.innerHTML = `💡 Ví dụ`;
            examplesBtn.className = 'control-btn'; // Use same class as others for styling
            examplesBtn.style.marginLeft = '0.5rem';
            examplesBtn.onclick = () => examplesModalOverlay.classList.add('show');
            generateBtn.parentNode.insertBefore(examplesBtn, generateBtn.nextSibling); // Insert next to generate button


            displayMessage("Hãy xem AI dự đoán và diễn họa phản ứng hóa học!");
            toggleDragHint(true);
            updateAtomLegend(null);
            updateInputState();
        }

        /** Shows the explanation modal. */
        function showExplanationModal(title, content, stepNumber) {
            explanationTitle.textContent = `Bước ${stepNumber}: ${title}`;
            explanationText.textContent = content;
            explanationModalOverlay.classList.add('show');
            [playPauseBtn, restartBtn, timelineSlider, ...speedButtons, explanationModeToggle].forEach(el => el.disabled = true);
        }

        /** Hides the explanation modal. */
        function hideExplanationModal() {
            explanationModalOverlay.classList.remove('show');
            // Only re-enable controls if mainTimeline exists and is not currently active (i.e., paused or completed)
            if (mainTimeline && !mainTimeline.isActive()) return;
            if(mainTimeline) {
                [playPauseBtn, restartBtn, timelineSlider, ...speedButtons, explanationModeToggle].forEach(el => el.disabled = false);
            }
        }

        /** Updates the atom legend based on the current reaction plan. */
        function updateAtomLegend(plan) {
            atomLegendContent.innerHTML = '';
            let uniqueAtomSymbols = new Set();
            if (plan) {
                plan.reactants.forEach(r => r.atoms.forEach(a => uniqueAtomSymbols.add(a.symbol)));
                plan.products.forEach(p => p.atoms.forEach(a => uniqueAtomSymbols.add(a.symbol)));
            } else {
                // Default atoms if no plan is active
                ['H', 'O', 'C'].forEach(s => uniqueAtomSymbols.add(s));
            }
            const atomsToShow = ATOM_COLORS.filter(atom => uniqueAtomSymbols.has(atom.symbol));
            if (atomsToShow.length === 0) {
                atomLegendContent.innerHTML = '<span class="text-sm text-gray-400">Không có chú thích.</span>';
                atomLegendContent.classList.add('expanded');
            } else {
                atomsToShow.forEach(atom => {
                    const item = document.createElement('div');
                    item.classList.add('atom-legend-item'); // Changed class for styling
                    item.innerHTML = `<div class="atom-color-circle" style="background-color: ${atom.color};"></div><span>${atom.symbol}</span>`;
                    atomLegendContent.appendChild(item);
                });
                atomLegendContent.classList.add('expanded');
                atomLegendToggle.style.transform = 'rotate(180deg)';
            }
        }

        // Initial load behavior
        showWelcomeModal();
        // Ensure legend is collapsed initially on page load
        atomLegendContent.classList.remove('expanded');
        atomLegendToggle.style.transform = 'rotate(0deg)';
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine H√≥a h·ªçc AI v3.0 - Nh√† H√≥a h·ªçc AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Variables CSS cho m√†u s·∫Øc d·ªÖ qu·∫£n l√Ω */
        :root {
            --dark-bg: #111827;
            --light-bg: #1f2937;
            --panel-bg: #374151;
            --accent-color: #8b5cf6; /* M√†u t√≠m l√†m ƒëi·ªÉm nh·∫•n */
            --danger-color: #ef4444; /* M√†u ƒë·ªè cho l·ªói */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e5e7eb; /* M√†u ch·ªØ s√°ng */
            padding: 1rem; /* Padding t·ªïng th·ªÉ */
        }
        .simulation-container {
            width: 95vw;
            max-width: 1000px;
            background: var(--light-bg);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column; /* S·∫Øp x·∫øp c√°c ph·∫ßn t·ª≠ theo chi·ªÅu d·ªçc */
            gap: 1rem; /* Kho·∫£ng c√°ch gi·ªØa c√°c ph·∫ßn t·ª≠ */
        }
        /* THAY ƒê·ªîI: Th√™m hi·ªáu ·ª©ng b√≥ng ƒë·ªï cho ti√™u ƒë·ªÅ */
        h1 {
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
            transition: text-shadow 0.3s ease-in-out;
        }
        h1:hover {
            text-shadow: 0 0 25px rgba(139, 92, 246, 1), 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #reaction-chamber {
            position: relative;
            width: 100%;
            height: 500px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh cho bu·ªìng ph·∫£n ·ª©ng */
            background: var(--dark-bg);
            border-radius: 1rem;
            overflow: hidden; /* ƒê·∫£m b·∫£o n·ªôi dung kh√¥ng tr√†n ra ngo√†i */
            cursor: grab; /* Con tr·ªè k√©o */
            display: flex; /* D√πng flexbox ƒë·ªÉ cƒÉn gi·ªØa n·ªôi dung l·ªói WebGL */
            justify-content: center;
            align-items: center;
        }
        #reaction-chamber canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-panel {
            background: var(--panel-bg);
            border-radius: 1rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        /* C·∫≠p nh·∫≠t style cho textarea */
        #equation-input {
            flex-grow: 1; /* Cho ph√©p textarea m·ªü r·ªông */
            background: var(--light-bg);
            border: 1px solid var(--accent-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #fff;
            outline: none; /* B·ªè vi·ªÅn outline m·∫∑c ƒë·ªãnh */
            transition: border-color 0.3s; /* Hi·ªáu ·ª©ng chuy·ªÉn m√†u vi·ªÅn */
            resize: vertical; /* Cho ph√©p thay ƒë·ªïi k√≠ch th∆∞·ªõc theo chi·ªÅu d·ªçc */
            min-height: 80px; /* Chi·ªÅu cao t·ªëi thi·ªÉu */
        }
        #equation-input:focus {
            border-color: #a78bfa; /* M√†u vi·ªÅn khi focus */
        }
        /* Class m·ªõi cho tr·∫°ng th√°i l·ªói */
        #equation-input.input-error {
            border-color: var(--danger-color);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.5); /* Shadow ƒë·ªè cho l·ªói */
        }

        .main-btn {
            background-image: linear-gradient(to right, #6366f1, var(--accent-color));
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông m∆∞·ª£t m√† */
            font-weight: 600;
            display: flex; /* D√πng flexbox ƒë·ªÉ cƒÉn gi·ªØa spinner v√† text */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .main-btn:hover {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            transform: translateY(-2px); /* Hi·ªáu ·ª©ng nh·∫•c nh·∫π */
        }
        .main-btn:disabled {
            background-image: none;
            background-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #controls-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap; /* Cho ph√©p c√°c n√∫t xu·ªëng d√≤ng tr√™n m√†n h√¨nh nh·ªè */
            justify-content: center; /* CƒÉn gi·ªØa c√°c n√∫t */
        }
        .icon-btn {
            background: transparent;
            border: 1px solid #6b7280;
            color: #d1d5db;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2rem;
        }
        .icon-btn:hover {
            border-color: var(--accent-color);
            color: white;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }
        .icon-btn:disabled {
            color: #6b7280;
            border-color: #4b5563;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Th√™m style cho thanh tr∆∞·ª£t t·ªëc ƒë·ªô v√† th·ªùi gian */
        .speed-control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem; /* Kho·∫£ng c√°ch v·ªõi thanh progress bar */
        }
        .speed-btn {
            background-color: var(--panel-bg);
            color: #e5e7eb;
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            border: 1px solid #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        .speed-btn:hover:not(.active) {
            border-color: var(--accent-color);
            color: white;
        }
        .speed-btn.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }
        .speed-btn:disabled {
            background-color: #4b5563;
            border-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }

        #timeline-slider {
            width: 100%;
            -webkit-appearance: none; /* ·∫®n giao di·ªán m·∫∑c ƒë·ªãnh */
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            margin-top: 1rem; /* Kho·∫£ng c√°ch v·ªõi c√°c n√∫t ƒëi·ªÅu khi·ªÉn */
        }
        #timeline-slider:hover {
            opacity: 1;
        }
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
        }


        #progress-container {
            flex-grow: 1;
            height: 8px;
            background: #4b5563;
            border-radius: 99px;
            overflow: hidden;
            display: none; /* ·∫®n thanh progress bar c≈©, thay b·∫±ng slider m·ªõi */
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 99px;
            transition: width 0.3s ease; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông cho thanh ti·∫øn tr√¨nh */
        }
        /* C·∫≠p nh·∫≠t style cho info-text ƒë·ªÉ n√≥ ho·∫°t ƒë·ªông nh∆∞ toast */
        #info-text {
            text-align: center;
            min-height: 24px; /* Gi·ªØ ch·ªó ƒë·ªÉ tr√°nh nh·∫£y layout */
            color: #e5e7eb;
            opacity: 0; /* M·∫∑c ƒë·ªãnh ·∫©n */
            transition: opacity 0.3s ease-in-out, color 0.3s ease-in-out; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªïi */
            font-size: 1rem; /* THAY ƒê·ªîI: TƒÉng k√≠ch th∆∞·ªõc ch·ªØ */
            font-weight: 600; /* THAY ƒê·ªîI: TƒÉng ƒë·ªô ƒë·∫≠m ch·ªØ */
        }
        #info-text.error-message {
            color: var(--danger-color); /* M√†u ƒë·ªè cho l·ªói */
        }

        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Th√¥ng b√°o l·ªói WebGL */
        .webgl-error-message {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--danger-color); /* N·ªÅn ƒë·ªè cho l·ªói */
            color: white;
            border-radius: 0.75rem;
            font-size: 1rem;
            max-width: 80%;
        }
        .webgl-error-message h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .webgl-error-message p {
            margin-bottom: 0.5rem;
        }
        .webgl-error-message a {
            color: #fee2e2;
            text-decoration: underline;
        }
        .webgl-error-message a:hover {
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <h1 class="text-2xl font-bold text-center mb-4">Nh√† H√≥a h·ªçc AI v3.0</h1>
        <div id="reaction-chamber">
            <!-- Th√¥ng b√°o l·ªói WebGL s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y n·∫øu c·∫ßn -->
        </div>
        <div class="ui-panel">
            <div class="input-group">
                <textarea id="equation-input" rows="3" placeholder="Nh·∫≠p c√°c ch·∫•t tham gia (vd: H2 + O2), ho·∫∑c ph∆∞∆°ng tr√¨nh (vd: 2H2 + O2 -> 2H2O), ho·∫∑c m√¥ t·∫£ (vd: Ph·∫£n ·ª©ng ƒë·ªët ch√°y Metan)..."></textarea>
                <button id="generate-btn" class="main-btn">
                    T·∫°o Ph·∫£n ·ª©ng
                    <div id="loading-spinner" class="spinner hidden"></div>
                </button>
            </div>
             <div id="controls-bar">
                <button id="play-pause-btn" class="icon-btn" disabled>‚ñ∂Ô∏è</button>
                <button id="restart-btn" class="icon-btn" disabled>üîÑ</button>
                
                <!-- THAY ƒê·ªîI: Th√™m nh√≥m ƒëi·ªÅu khi·ªÉn t·ªëc ƒë·ªô -->
                <div class="speed-control-group">
                    <button class="speed-btn" data-speed="0.5" disabled>0.5x</button>
                    <button class="speed-btn active" data-speed="1" disabled>1x</button>
                    <button class="speed-btn" data-speed="2" disabled>2x</button>
                </div>

                <!-- Thanh progress bar c≈© (gi·ªù ·∫©n ƒëi) -->
                <div id="progress-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <!-- THAY ƒê·ªîI: Th√™m thanh tr∆∞·ª£t th·ªùi gian -->
            <input type="range" id="timeline-slider" min="0" max="100" value="0" disabled>

            <p id="info-text">H√£y xem AI d·ª± ƒëo√°n v√† di·ªÖn h·ªça ph·∫£n ·ª©ng h√≥a h·ªçc!</p>
        </div>
    </div>

    <!-- Imports -->
    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/" } }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Firebase, AI, 3D Engine Setup ---
        const firebaseConfig = { apiKey: "AIzaSyBVpguEIjTnIVOk1Ld0u-BGC7nM-pSww_o", authDomain: "aihoa-ac63b.firebaseapp.com", projectId: "aihoa-ac63b", storageBucket: "aihoa-ac63b.firebasestorage.app", messagingSenderId: "241068548961", appId: "1:241068548961:web:33d4126d020e9372d15b20"};
        let model;
        try {
            const app = initializeApp(firebaseConfig);
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            // S·ª≠ d·ª•ng gemini-2.5-flash ƒë·ªÉ t·∫°o n·ªôi dung
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
        } catch (e) {
            console.error("L·ªói kh·ªüi t·∫°o Firebase/AI:", e);
            // Hi·ªÉn th·ªã l·ªói n·∫øu kh√¥ng th·ªÉ kh·ªüi t·∫°o AI
            displayMessage("L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi AI Engine. Vui l√≤ng ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.", true);
            document.getElementById('generate-btn').disabled = true;
        }

        const chamber = document.getElementById('reaction-chamber');
        let renderer, scene, camera, controls, composer, mainTimeline;
        let molecules = [];
        let particles; // Khai b√°o bi·∫øn cho h·ªá th·ªëng h·∫°t

        function init3D() {
            // X√≥a n·ªôi dung l·ªói WebGL c≈© n·∫øu c√≥
            chamber.innerHTML = '';
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, chamber.clientWidth / chamber.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                chamber.appendChild(renderer.domElement);

                // C√†i ƒë·∫∑t Post-processing (Bloom effect)
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;
                const outputPass = new OutputPass();

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);
                composer.addPass(outputPass);

                // Th√™m ƒë√®n
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 10, 7.5);
                scene.add(directionalLight);

                camera.position.z = 15;

                // ƒêi·ªÅu khi·ªÉn OrbitControls cho ph√©p xoay, ph√≥ng to/thu nh·ªè khung c·∫£nh
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // Th√™m h·ªá th·ªëng h·∫°t (particles)
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const particleColor = new THREE.Color(0xffffff); // M√†u tr·∫Øng
                const sphereRadius = 20; // B√°n k√≠nh khu v·ª±c h·∫°t xu·∫•t hi·ªán

                for (let i = 0; i < particleCount; i++) {
                    // T·∫°o v·ªã tr√≠ ng·∫´u nhi√™n trong m·ªôt h√¨nh c·∫ßu
                    const x = (Math.random() - 0.5) * 2 * sphereRadius;
                    const y = (Math.random() - 0.5) * 2 * sphereRadius;
                    const z = (Math.random() - 0.5) * 2 * sphereRadius;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // G√°n m√†u tr·∫Øng v·ªõi ƒë·ªô m·ªù nh·∫π
                    colors[i * 3] = particleColor.r;
                    colors[i * 3 + 1] = particleColor.g;
                    colors[i * 3 + 2] = particleColor.b;
                }

                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1, // K√≠ch th∆∞·ªõc h·∫°t
                    vertexColors: true, // S·ª≠ d·ª•ng m√†u t·ª´ attribute
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending // Hi·ªáu ·ª©ng c·ªông m√†u, l√†m h·∫°t s√°ng h∆°n
                });

                particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                particles.visible = true; // M·∫∑c ƒë·ªãnh hi·ªÉn th·ªã h·∫°t

                // V√≤ng l·∫∑p ho·∫°t ·∫£nh ch√≠nh
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    // Quay c√°c h·∫°t nh·∫π nh√†ng
                    if (particles && particles.visible) {
                        particles.rotation.y += 0.0005;
                        particles.rotation.x += 0.0002;
                    }
                    composer.render();
                }
                animate();

                // L·∫Øng nghe s·ª± ki·ªán thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
                window.addEventListener('resize', () => {
                    camera.aspect = chamber.clientWidth / chamber.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(chamber.clientWidth, chamber.clientHeight);
                    composer.setSize(chamber.clientWidth, chamber.clientHeight);
                });

            } catch (error) {
                console.error("L·ªói kh·ªüi t·∫°o WebGL:", error);
                // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói th√¢n thi·ªán h∆°n
                chamber.innerHTML = `
                    <div class="webgl-error-message">
                        <h2>L·ªói WebGL</h2>
                        <p>Tr√¨nh duy·ªát c·ªßa b·∫°n c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ ho·∫∑c WebGL ƒëang b·ªã t·∫Øt.</p>
                        <p>ƒê·ªÉ tr·∫£i nghi·ªám ho·∫°t ·∫£nh 3D, vui l√≤ng ƒë·∫£m b·∫£o tr√¨nh duy·ªát c·ªßa b·∫°n ƒë∆∞·ª£c c·∫≠p nh·∫≠t v√† WebGL ƒë∆∞·ª£c b·∫≠t.</p>
                        <p><a href="https://get.webgl.org/" target="_blank">Ki·ªÉm tra tr·∫°ng th√°i WebGL c·ªßa b·∫°n t·∫°i ƒë√¢y</a></p>
                    </div>
                `;
                generateBtn.disabled = true;
                throw new Error("WebGL init failed");
            }
        }

        // --- Core Application Logic ---
        const generateBtn = document.getElementById('generate-btn');
        const input = document.getElementById('equation-input');
        const infoText = document.getElementById('info-text');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const speedButtons = document.querySelectorAll('.speed-btn');
        const timelineSlider = document.getElementById('timeline-slider');

        let currentMessageTimeout;
        function displayMessage(message, isError = false) {
            if (currentMessageTimeout) {
                clearTimeout(currentMessageTimeout);
                currentMessageTimeout = null;
            }

            infoText.textContent = message;
            if (isError) {
                infoText.classList.add('error-message');
            } else {
                infoText.classList.remove('error-message');
            }
            gsap.to(infoText, { opacity: 1, duration: 0.3, ease: "power2.out" });

            if (!isError) {
                currentMessageTimeout = setTimeout(() => {
                    gsap.to(infoText, { opacity: 0, duration: 0.5, ease: "power2.in" });
                }, 5000);
            }
        }

        function clearScene() {
            molecules.forEach(m => {
                m.children.forEach(c => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                });
                scene.remove(m);
            });
            molecules = [];
        }

        function drawMolecule3D(moleculeDef, x, y, z) {
            const group = new THREE.Group();
            const atomRadius = 0.5;

            moleculeDef.atoms.forEach((atomDef, i) => {
                const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: atomDef.color,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: '#000000'
                });
                const atomMesh = new THREE.Mesh(geometry, material);

                if (moleculeDef.atoms.length > 1) {
                    const angle = (i / moleculeDef.atoms.length) * 2 * Math.PI;
                    atomMesh.position.x = Math.cos(angle) * atomRadius * 1.5;
                    atomMesh.position.y = Math.sin(angle) * atomRadius * 1.5;
                }
                group.add(atomMesh);
            });

            group.position.set(x, y, z);
            scene.add(group);
            molecules.push(group);
            return group;
        }

        // --- Animation Engine ---
        function runAnimation(plan) {
            if (mainTimeline) mainTimeline.kill();
            clearScene();
            
            // ·∫®n c√°c h·∫°t khi ho·∫°t ·∫£nh b·∫Øt ƒë·∫ßu
            if (particles) {
                particles.visible = false;
            }

            displayMessage(`ƒêang chu·∫©n b·ªã ho·∫°t ·∫£nh cho: ${plan.title}`);

            mainTimeline = gsap.timeline({
                onUpdate: () => {
                    timelineSlider.value = mainTimeline.progress() * 100;
                    playPauseBtn.textContent = mainTimeline.paused() ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
                },
                onComplete: () => {
                    displayMessage("Ho·∫°t ·∫£nh ho√†n t·∫•t!");
                    playPauseBtn.textContent = "‚ñ∂Ô∏è";
                    playPauseBtn.disabled = true;
                    timelineSlider.disabled = true;
                    speedButtons.forEach(btn => btn.disabled = true);
                    // Hi·ªán c√°c h·∫°t khi ho·∫°t ·∫£nh k·∫øt th√∫c
                    if (particles) {
                        particles.visible = true;
                    }
                }
            });

            playPauseBtn.disabled = false;
            restartBtn.disabled = false;
            timelineSlider.disabled = false;
            speedButtons.forEach(btn => btn.disabled = false);

            playPauseBtn.textContent = "‚è∏Ô∏è";

            const reactantObjects = [];
            let reactantX = -10;

            plan.reactants.forEach((r) => {
                for (let j = 0; j < r.count; j++) {
                    const moleculeObj = drawMolecule3D(r, reactantX, (j % 2 === 0 ? 1 : -1) * 4, 0);
                    reactantObjects.push({ obj: moleculeObj });
                    reactantX += 5;
                }
            });

            plan.animationSteps.forEach(step => {
                mainTimeline.add(() => { displayMessage(step.text || '...'); }, step.type);

                if (step.type === 'move_to_center') {
                    mainTimeline.to(camera.position, { z: 25, duration: 2.5, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach((m, i) => {
                        mainTimeline.to(m.obj.position, { x: (i % 3 - 1) * 3, y: Math.floor(i / 3) * 3 - 1, z: 0, duration: 2.5, ease: "power2.inOut" }, step.type);
                    });
                } else if (step.type === 'break_bonds') {
                    mainTimeline.to(camera.position, { z: 12, duration: 2, ease: "power2.inOut"}, step.type);
                    reactantObjects.forEach(m => {
                        m.obj.children.forEach((atomMesh, i) => {
                            mainTimeline.to(atomMesh.material.emissive, { r: 1, g: 1, b: 0.8, duration: 1, ease: "power2.in" }, step.type);
                            const angle = (i / m.obj.children.length) * 2 * Math.PI;
                            mainTimeline.to(atomMesh.position, { x: atomMesh.position.x + Math.cos(angle) * 0.8, y: atomMesh.position.y + Math.sin(angle) * 0.8, duration: 2, ease: "back.out(4)" }, step.type);
                        });
                    });
                } else if (step.type === 'rearrange') {
                    reactantObjects.forEach(m => {
                        mainTimeline.to(m.obj.children.map(c => c.material), { opacity: 0, duration: 1, onComplete: () => scene.remove(m.obj) }, step.type);
                    });

                    if (plan.isExothermic) {
                        mainTimeline.add(() => {
                            const shockwaveGeo = new THREE.TorusGeometry(1, 0.1, 16, 100);
                            const shockwaveMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 1 });
                            const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
                            shockwave.rotation.x = Math.PI / 2;
                            scene.add(shockwave);
                            gsap.to(shockwave.scale, { x: 20, y: 20, z: 20, duration: 2, ease: "power1.out" });
                            gsap.to(shockwave.material, { opacity: 0, duration: 2, ease: "power1.out", onComplete: () => scene.remove(shockwave) });
                        }, step.type + "+=0.5");

                    }

                    let productX = -5;
                    plan.products.forEach(p => {
                        for (let j = 0; j < p.count; j++) {
                            const productObj = drawMolecule3D(p, productX, (j % 2 === 0 ? 1 : -1) * 3, 0);
                            productObj.children.forEach(c => { c.material.transparent = true; c.material.opacity = 0; });
                            mainTimeline.to(productObj.children.map(c => c.material), { opacity: 1, duration: 2 }, step.type + "+=1");
                            mainTimeline.to(productObj.children.map(c => c.material.emissive), { r: 0, g: 0, b: 0, duration: 2 }, step.type + "+=1");
                            productX += 5;
                        }
                    });
                }
            });
        }

        async function generateReactionPlan() {
            if (!model || !renderer) {
                displayMessage("L·ªói: Engine AI ho·∫∑c m√¥i tr∆∞·ªùng 3D ch∆∞a s·∫µn s√†ng.", true);
                return;
            }
            const userInput = input.value.trim();
            if (!userInput) {
                displayMessage("Vui l√≤ng nh·∫≠p c√°c ch·∫•t tham gia ƒë·ªÉ t·∫°o ph·∫£n ·ª©ng.", true);
                input.classList.add('input-error');
                return;
            } else {
                input.classList.remove('input-error');
            }

            displayMessage('AI ƒëang t∆∞ duy... üß†');
            generateBtn.disabled = true;
            loadingSpinner.classList.remove('hidden');
            playPauseBtn.disabled = true;
            restartBtn.disabled = true;
            timelineSlider.disabled = true;
            speedButtons.forEach(btn => btn.disabled = true);

            // ·∫®n c√°c h·∫°t khi AI ƒëang t·∫°o ph·∫£n ·ª©ng
            if (particles) {
                particles.visible = false;
            }

            const prompt = `
            T·ª´ c√°c ch·∫•t tham gia do ng∆∞·ªùi d√πng cung c·∫•p l√†: "${userInput}".
            H√£y th·ª±c hi·ªán c√°c b∆∞·ªõc sau m·ªôt c√°ch tu·∫ßn t·ª±:
            1. D·ª± ƒëo√°n s·∫£n ph·∫©m h√≥a h·ªçc c√≥ kh·∫£ nƒÉng x·∫£y ra nh·∫•t trong ƒëi·ªÅu ki·ªán ti√™u chu·∫©n.
            2. Vi·∫øt ph∆∞∆°ng tr√¨nh h√≥a h·ªçc ƒë·∫ßy ƒë·ªß v√† ƒë√£ ƒë∆∞·ª£c c√¢n b·∫±ng cho ph·∫£n ·ª©ng ƒë√≥.
            3. D·ª±a tr√™n ph∆∞∆°ng tr√¨nh b·∫°n v·ª´a t·∫°o, h√£y t·∫°o m·ªôt k·ªãch b·∫£n ho·∫°t ·∫£nh chi ti·∫øt d∆∞·ªõi d·∫°ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON.

            ƒê·ªëi t∆∞·ª£ng JSON ph·∫£i c√≥ c·∫•u tr√∫c ch√≠nh x√°c nh∆∞ sau:
            - "title": (string) Ph∆∞∆°ng tr√¨nh h√≥a h·ªçc ƒë·∫ßy ƒë·ªß m√† b·∫°n ƒë√£ t·∫°o (v√≠ d·ª•: "2H2 + O2 -> 2H2O").
            - "isExothermic": (boolean) Ph·∫£n ·ª©ng c√≥ t·ªèa nhi·ªát hay kh√¥ng (true n·∫øu t·ªèa nhi·ªát, false n·∫øu thu nhi·ªát ho·∫∑c kh√¥ng x√°c ƒë·ªãnh).
            - "reactants": (array) M·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng ch·∫•t ph·∫£n ·ª©ng, m·ªói ƒë·ªëi t∆∞·ª£ng c√≥ d·∫°ng {molecule: string, count: number, atoms: [{symbol: string, color: string}]}.
            - "products": (array) M·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng s·∫£n ph·∫©m, c·∫•u tr√∫c t∆∞∆°ng t·ª± reactants.
            - "animationSteps": (array) M·ªôt m·∫£ng c√°c b∆∞·ªõc ho·∫°t ·∫£nh, m·ªói b∆∞·ªõc c√≥ d·∫°ng {type: 'move_to_center' | 'break_bonds' | 'rearrange', text: string}.
                - 'move_to_center': C√°c ph√¢n t·ª≠ di chuy·ªÉn v√†o trung t√¢m bu·ªìng ph·∫£n ·ª©ng.
                - 'break_bonds': Li√™n k·∫øt gi·ªØa c√°c nguy√™n t·ª≠ b·ªã ph√° v·ª°, c√°c nguy√™n t·ª≠ t√°ch r·ªùi.
                - 'rearrange': C√°c nguy√™n t·ª≠ t·ª± s·∫Øp x·∫øp l·∫°i ƒë·ªÉ t·∫°o th√†nh s·∫£n ph·∫©m m·ªõi.

            S·ª≠ d·ª•ng c√°c m√†u sau cho nguy√™n t·ª≠ (h√£y t·ª± suy ra c√°c m√†u kh√°c n·∫øu c·∫ßn):
            - H: #FFFFFF (Tr·∫Øng)
            - O: #FF6B6B (ƒê·ªè)
            - C: #333333 (X√°m ƒëen)
            - N: #6B9AFF (Xanh d∆∞∆°ng)
            - Fe: #A19D94 (X√°m kim lo·∫°i)
            - S: #FFF36B (V√†ng)
            - Cl: #6BFF8B (Xanh l√°)
            - Na: #B06BFF (T√≠m)
            - K: #8A2BE2 (T√≠m nh·∫°t)
            - Mg: #BDB76B (V√†ng xanh)
            - Ca: #DDA0DD (T√≠m hoa c√†)
            - Al: #C0C0C0 (B·∫°c)
            - P: #FFA500 (Cam)
            - Br: #A52A2A (N√¢u)
            - I: #4B0082 (Ch√†m)

            Quan tr·ªçng: Ch·ªâ tr·∫£ l·ªùi b·∫±ng m·ªôt kh·ªëi m√£ JSON h·ª£p l·ªá duy nh·∫•t, kh√¥ng ch·ª©a "'''json" hay b·∫•t k·ª≥ vƒÉn b·∫£n gi·∫£i th√≠ch n√†o kh√°c.
            `;

            try {
                const result = await model.generateContent(prompt);
                const textResponse = result.response.text();
                const cleanedText = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
                const plan = JSON.parse(cleanedText);

                runAnimation(plan);
            } catch (error) {
                console.error("L·ªói ph√¢n t√≠ch ho·∫∑c t·∫°o ho·∫°t ·∫£nh:", error);
                displayMessage("ƒê√£ c√≥ l·ªói x·∫£y ra. AI c√≥ th·ªÉ ƒë√£ tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng ho·∫∑c g·∫∑p l·ªói. Vui l√≤ng th·ª≠ l·∫°i.", true);
                // Hi·ªán c√°c h·∫°t tr·ªü l·∫°i n·∫øu c√≥ l·ªói
                if (particles) {
                    particles.visible = true;
                }
            } finally {
                generateBtn.disabled = false;
                loadingSpinner.classList.add('hidden');
            }
        }

        playPauseBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.paused(!mainTimeline.paused());
            }
        });

        restartBtn.addEventListener('click', () => {
            if (mainTimeline) {
                mainTimeline.restart();
            }
        });

        speedButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const speed = parseFloat(event.target.dataset.speed);
                if (mainTimeline) {
                    mainTimeline.timeScale(speed);
                }
                speedButtons.forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            });
        });

        timelineSlider.addEventListener('input', () => {
            if (mainTimeline) {
                mainTimeline.progress(timelineSlider.value / 100);
            }
        });

        init3D();
        generateBtn.addEventListener('click', generateReactionPlan);
        displayMessage("H√£y xem AI d·ª± ƒëo√°n v√† di·ªÖn h·ªça ph·∫£n ·ª©ng h√≥a h·ªçc!");
    </script>
</body>
</html>
